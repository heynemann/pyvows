<!doctype html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <title>pyVows &laquo; Asynchronous BDD for Python</title>

    <link rel="alternate stylesheet" type="text/less" href="./media/main.less">
    <script src="./media/less.js" type="text/javascript"></script>

    <link href='http://fonts.googleapis.com/css?family=Droid+Serif|Lobster' rel='stylesheet' type='text/css'>
    <link href="./media/shThemeFadeToGrey.css" rel="stylesheet" type="text/css" />
    <link rel="alternate" type="application/atom+xml" title="app - feed" href="./index.xml" />
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-23196100-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
    <style>
        .syntaxhighlighter {
            background-color: #191919 !important;
            border: dashed 1px #F9F9B3;
            padding: 8px;
        }
        .syntaxhighlighter .line.alt1,
        .syntaxhighlighter .line.alt2 {
            background-color: #191919 !important;
        }
        .syntaxhighlighter .toolbar {
            display: none;
        }
        .syntaxhighlighter .gutter .line {
            border-right: 3px solid #302D2C !important;
            text-align: center;
            padding-right: 7px;
        }

        .syntaxhighlighter.python code {
            background-color: #191919 !important;
        }

        .syntaxhighlighter .decorator, .syntaxhighlighter .decorator a {
            color: white !important;
        }

    </style>
    <script type="text/javascript">
      (function () {
          if (document.querySelectorAll) {
            window.onload = function () {
              var menu = document.getElementById('menu');
              var init = menu.offsetTop;
              var docked;

              var headers = document.querySelectorAll('#docs h2, #synopsis h2');

              for (var i = 0; i < headers.length; i++) {
                headers[i].id = '-' + headers[i].innerHTML.toLowerCase().replace(/ /g, '-');
              }

              window.onscroll = function () {
                if (!docked && (menu.offsetTop - scrollTop() < 0)) {
                  menu.style.top = 0;
                  menu.style.position = 'fixed';
                  menu.className = 'docked';
                  docked = true;
                } else if (docked && scrollTop() <= init) {
                  menu.style.position = 'absolute';
                  menu.style.top = init + 'px';
                  menu.className = menu.className.replace('docked', '');
                  docked = false;
                }
              };


              (function () {
                var link     = document.getElementById('guide-link'),
                    menu     = document.getElementById('menu'),
                    dropdown = document.getElementById('dropdown');

                link.onmouseover = function () {
                  link.className = 'dark-red';
                  dropdown.style.display = 'block';
                };
                link.onmouseout = function (e) {
                  if (e.relatedTarget === dropdown) { return }
                  link.className = link.className.replace('dark-red', '');
                  hide ();
                };
                dropdown.onmouseout = function (e) {
                  var t = e.relatedTarget;

                  if (e.target == link) { return }

                  while (t !== document.body) {
                    if (t == dropdown) { return }
                    else               { t = t.parentNode }
                  }
                  link.className = link.className.replace('dark-red', '');
                  hide ();
                };

                function hide() { dropdown.style.display = 'none' }
              })();
            };
          } else {
            alert('Please upgrade to a modern browser to view this site.');
          }

        function scrollTop() {
          return document.body.scrollTop || document.documentElement.scrollTop;
        }
      })();
    </script>
  </head>
  <body>
    <section>
      <header id="main">
  <div class="content">
    <section id="intro">
      <h1>pyVows</h1>
      <h2><span>Asynchronous</span> behaviour driven <span>development</span> for Python.</h2>
      <h3>
        The main reason for asynchronous testing is to make tests which target I/O
        run much faster, by running them concurrently. <br /><br />By having a faster suite, it gets run that more often,
        thus improving the feedback cycle.
      </h3>
    </section>

    <section id="example">
        <p>Write some vows, execute them:</p>
        <pre class="command">$ pyvows test/ </pre>
        <p>Get the report, make sure you kept your word.</p>
        <pre>A non-promise return value
  &#10003; <span class="vow">should be converted to a promise</span>
A topic not emitting an error
  &#10003; <span class="vow">should pass null if the test is expecting an error</span>
  &#10003; <span class="vow">should pass the result otherwise</span>
A topic emitting an error
  &#10003; <span class="vow">shouldn't raise an exception if the test expects it</span>
A context with a nested context
  &#10003; <span class="vow">has access to the environment</span>
  &#10003; <span class="vow">can make coffee</span>
A nested context
  &#10003; <span class="vow">should have access to the parent topics</span>
A nested context with no topics
  &#10003; <span class="vow">should pass the parent topics down</span>

&#10003; <span id="ok">OK</span> &#187; <strong>8</strong> honored &bull; <strong>0</strong> broken <span id="time">(0.112s)</span></pre>
    </section>
  </div>
  <div style="clear: both"></div>
</header>

<section id="menu">
  <div class="content">
    <nav>
      <a href="#intro">intro</a>
      <a href="#docs" id="guide-link">guide</a>
      <a href="#installing">installing</a>
      <a href="#reference">reference</a>
      <a href="#about">about</a>
      <a href="http://github.com/heynemann/pyvows">source <img id="github" src="./media/github.ico"/></a>
    </nav>
    <div id="dropdown">
      <ul>
        <li><a href="#-structure-of-a-test-batch">Structure of a Test Batch</a></li>
        <li><a href="#-how-topics-work">How topics work</a></li>
        <li><a href="#-running-a-suite">Running a Suite</a></li>
        <li><a href="#-context-inheritance">Context Inheritance</a></li>
        <li><a href="#-using-generative-testing">Generative Testing</a></li>
        <li><a href="#-asynchronous-topics">Asynchronous Topics</a></li>
        <li><a href="#-assertions">Assertions</a></li>
      </ul>
    </div>
  </div>
</section>

<section id="synopsis">
    <div class="content">
        <h1>Synopsis</h1>

        <p>pyVows is a <a href="http://en.wikipedia.org/wiki/Behavior_Driven_Development">behavior driven development</a> framework for <a href="http://www.python.org">Python</a>.</p>

        <p>pyVows is inspired by <a href="http://vowsjs.org">Vows</a>, a BDD framework for node.js.</p>

        <p>Much of what's written here is based or the same as in <a href="http://vowsjs.org">Vows</a> docs.</p>

        <p>As its node.js counterpart, pyVows executes your tests in parallel when it makes sense,
        and sequentially when there are dependencies.</p>

        <p>Imagine we are testing a method that sums up two integers, like this:</p>

        <pre class="brush:python">
def test_sum_returns_42():
    result = add_two_numbers(41, 1)

    assert result
    assert int(result)
    assert result == 42
        </pre>

        <p>Even in a VERY simple scenario like this, we have three assertions in this test. Not too good if we want a single assertion per test, so we could do it like this:</p>

        <pre class="brush:python">
def test_sum_returns_result():
    result = add_two_numbers(41, 1)
    assert result

def test_sum_returns_a_number():
    result = add_two_numbers(41, 1)
    assert int(result)

def test_sum_returns_42():
    result = add_two_numbers(41, 1)
    assert result == 42
        </pre>

        <p>This is all fine and dandy, except that we are executing the add_two_numbers function three times. In this simple scenario we don't really care if it gets executed many times, but with real code we want to minimize calls so our tests are always as fast as possible.</p>

        <p>This is how the above test would look like in pyVows:</p>

        <pre class="brush:python">
class SumContext(Vows.Context):

    def topic(self):
        return add_two_numbers(41, 1)

    def we_get_a_result(self, topic):
        expect(topic).Not.to_be_null()

    def we_get_a_number(self, topic):
        expect(topic).to_be_numeric()

    def we_get_42(self, topic):
        expect(topic).to_equal(42)
        </pre>

        <p>Don't worry if you don't understand all of it. We'll see it more thoroughly in the next sections.</p>

        <p>Here&rsquo;s another example, this time describing &lsquo;division by zero&rsquo;:</p>

        <pre class="brush:python">
# division_by_zero_vows.py

from pyvows import Vows, expect

# Create a Test Batch
@Vows.batch
class Divisions(Vows.Context):
    class WhenDividingANumberByZero(Vows.Context):
        def topic(self):
            return 42 / 0

        def we_get_division_by_zero_error(self, topic):
            expect(topic).to_be_an_error_like(ZeroDivisionError)

    class WhenDividingByOne(Vows.Context):
        def topic(self):
            return 42 / 1

        def we_get_the_same_number(self, topic):
            expect(topic).to_equal(42)

        </pre>

        <p>And run it:</p>

        <pre><code>$ pyvows division_by_zero_vows.py</code></pre>

        <hr />

        <p>And now, a little more involved example&mdash;let&rsquo;s suppose we have a module called &lsquo;<code>the_good_things</code>&rsquo;, with some fruit in it:</p>

        <pre class="brush:python">
class Strawberry(object):
    def __init__(self):
        self.color = '#ff0000';

    def isTasty(self):
        return True

class PeeledBanana(object): pass

class Banana(object):
    def __init__(self):
        self.color = '#fff333';

    def peel(self):
        return PeeledBanana()
        </pre>

        <p>Now write some tests in <em>the_good_things_vows.py</em>:</p>

        <pre class="brush:python">
from pyvows import Vows, expect

from the_good_things import Strawberry, Banana, PeeledBanana

@Vows.batch
class TheGoodThings(Vows.Context):
    class AStrawberry(Vows.Context):
        def topic(self):
            return Strawberry()

        def is_red(self, topic):
            expect(topic.color).to_equal('#ff0000')

        def and_tasty(self, topic):
            expect(topic.isTasty()).to_be_true()

    class ABanana(Vows.Context):
        def topic(self):
            return Banana()

        class WhenPeeled(Vows.Context):
            def topic(self, banana):
                return banana.peel()

            def returns_a_peeled_banana(self, topic):
                expect(topic).to_be_instance_of(PeeledBanana)
        </pre>

        <p>And run them with the test runner:</p>

        <pre><code>$ pyvows the_good_things_vows.py</code></pre>

    </div>
</section>

<section id="installing">
    <div class="content">
        <h1>Installing</h1>

        <p>The easiest way to install pyVows, is via <a href="http://www.pip-installer.org/en/latest/index.html">pip</a>, the python package manager, as so:</p>

        <pre><code>$ pip install pyvows</code></pre>

        <p>Or to upgrade:</p>

        <pre><code>$ pip install -U pyvows</code></pre>

        <p>Note: If you are on a Debian like system (Ubuntu) and the pyVows fails to install,
        you may need to install these packages (as root):</p>

        <pre><code># apt-get install libxslt-dev libxml2-dev</code></pre>

        <p>After installing the packages, try to install pyVows again.</p>
    </div>
</section>

<section id="docs">
    <div class="content">
        <h1>Guide</h1>

        <p>To understand pyVows, we&rsquo;re going to start with a general overview of the different components involved in writing tests, and then go through some of them in more detail.</p>

        <h2>Structure of a test batch</h2>

        <p>Test batches in pyVows are the largest unit of tests. The convention is to have one test batch per file, and have the batch&rsquo;s class match the file name. Test batches are created with <code>@Vows.batch</code> decorator.</p>

        <pre class="brush:python">
@Vows.batch
class MyTestVows(Vows.Context):
    pass
        </pre>

        <p>Tests are added to suites in <em>batches</em>. This is done with the <code>@Vows.batch</code> decorator.</p>

        <p>You can have as many batches in a suite as you want.</p>

        <p>Batches are <em>contexts</em>, that can in itself contain <em>contexts</em>, which describe different components and states you want to test.</p>

        <pre class="brush:python">
@Vows.batch
class AContext(Vows.Context):
    pass

@Vows.batch
class AnotherContext(Vows.Context):
    pass
        </pre>

        <p>Contexts are executed <em>in parallel</em>, and they are fully asynchronous. The order in which they finish is therefore undefined.</p>

        <p>Contexts usually contain <em>topics</em> and <em>vows</em>, which in combination define your tests.</p>

        <pre class="brush:python">
@Vows.batch
class AContext(Vows.Context):
    def topic(self):
        return "something"

    def i_am_a_vow(self, topic):
        # Test the results of the topic
        </pre>

<p>Contexts can contain <em>sub-contexts</em> which get executed as soon as the parent context finishes:</p>

        <pre class="brush:python">
@Vows.batch
class AContext(Vows.Context):
    def topic(self):
        return "something"

    def i_am_a_vow(self, topic):
        # Test the results of the topic

    class SubContext(Vows.Context):
        # Executed when AContext is done
        pass

@Vows.batch
class AnotherContext(Vows.Context):
    # Executed in Parallel to AContext
    pass
        </pre>

        <h3>Summary</h3>

        <p>» A <em>Suite</em> is a set of one or more <em>batches</em> that pyVows will execute.</p>

        <p>» A <em>batch</em> is a context, representing a structure of nested <em>contexts</em>.</p>

        <p>» A <em>context</em> is a class with an optional <em>topic</em>, zero or more <em>vows</em> and zero or more <em>sub-contexts</em>.</p>

        <p>» A <em>topic</em> is a function that returns a value.</p>

        <p>» A <em>vow</em> is a function which receives the <em>topic</em> as an argument, and runs an assertion on it.</p>

        <p>With that in mind, we can imagine the following grammar:</p>

        <pre><code>Suite   → Batch*
        Batch   → Context*
        Context → Topic? Vow* Context*
        </code></pre>

        <p>Here&rsquo;s an annotated example:</p>

        <pre class="brush:python">
@Vows.batch                                             # Batch
class Array(Vows.Context):                              # Context
    class AnArray(Vows.Context):                        # Sub-Context
        class WithThreeElements(Vows.Context):
            def topic(self):                            # Topic
                return [1, 2, 3]

            def has_length_of_3(self, topic):           # Vow
                expect(topic).to_length(3)              # Assertion

        class WithZeroElements(Vows.Context):           # Sub-Context
            def topic(self):                            # Topic
                return []

            def has_a_length_of_0(self, topic):         # Vow
                expect(topic).to_length(0)              # Assertion

            class WhenPopped(Vows.Context):
                def topic(self, previous_topic):
                    return previous_topic.pop()

                def raises_when_popped(self, topic):
                    expect(topic).to_be_an_error_like(IndexError)
        </pre>

        <h2>How topics work</h2>

        <p><a href="http://vowsjs.org" target="_blank">Vows</a> introduces an <strong>incredibly powerful</strong>, yet very simple way of writing your tests. pyVows leverages the same approach towards the same goals.</p>
        <p>Understanding <em>topics</em> is one of the keys to understanding pyVows. Unlike other testing frameworks, pyVows forces a clear separation between the element which is tested, the <em>topic</em>, and the actual tests, the <em>vows</em>.</p>

        <p>Let&rsquo;s start with a simple example of a context:</p>

        <pre class="brush:python">
class Test42(Vows.Context):
    def topic(self):
        return 42

    def should_be_equal_to_42(self, topic):
        expect(topic).to_equal(42)
        </pre>

        <p>So this shows us that the value of the topic is passed down to our test function (refered to as a <em>vow</em> from now on) as an argument.
        Simple enough. Now what if we have multiple vows?</p>

        <pre class="brush:python">
@Vows.batch
class Test42(Vows.Context):
    def topic(self):
        return 42

    def should_be_a_number(self, topic):
        expect(topic).to_be_numeric()

    def should_be_equal_to_42(self, topic):
        expect(topic).to_equal(42)
        </pre>

        <p>It works as expected, the value is passed down to each <em>vow</em>. Note that the topic function is <strong>only run once</strong>.</p>

        <h3>Scope</h3>

        <p>Sometimes, you might need a parent topic&rsquo;s value, from inside a child topic. This is easy, because there is a notion of topic <em>scope</em>. Let&rsquo;s look at an example:</p>

        <pre class="brush:python">
@Vows.batch
class DataStore(Vows.Context):
    def topic(self):
        return DataStore()

    def should_respond_to_get(self, store):
        expect(store.get).to_be_a_function()

    def should_respond_to_put(self, store):
        expect(store.put).to_be_a_function()

    class CallingGet(Vows.Context):
        def topic(self, store):
            return store.get(42)

        def should_return_the_object_with_id_42(self, topic):
            expect(topic.id).toEqual(42)
        </pre>

        <p>In the example above, the value of the top-level topic is passed as an argument to the inner topic, in the same manner it&rsquo;s passed to the vows. For clarity, I named both arguments which refer to the outer topic as <code>store</code>.</p>

        <p>Note that the scoping isn&rsquo;t limited to a single level. Consider:</p>

<pre class="brush:python">
def topic(self, a, b, c):
    # a being the Parent topic
    # b being the Parent of parent topic
    # c being the Parent of parent of parent topic

    # return something
</pre>

        <p>So the parent topics are passed along to each topic function in the certain order: the immediate parent is always the first argument (<code>a</code>), and the outer topics follow (<code>b</code>, then <code>c</code>), like the layers of an onion.</p>

        <h2>Running a suite</h2>

        <p>The simplest way to run a test suite, is with the <code>pyvows</code> command:</p>

<pre><code>pyvows vows/my_vows.py
</code></pre>

<p>The results will be printed to the console with the default reporter, which is <strong>very similar</strong> to <a href="http://vowsjs.org">Vows</a> <code>'dot-matrix'</code> reporter.</p>

        <h3>Running larger suites</h3>

        <p>When your tests become more complex, spanning multiple files, you&rsquo;re going to need a way to run them as a single entity.</p>

        <p>pyVows' test runner, can be used to run multiple test suites at once. To make use of it, just run it passing the directory as the argument, instead of the file, like this:</p>

        <pre><code>pyvows vows/</code></pre>

        <p>We can also pass options to <code>pyvows</code>. For example, to get pyvows to run only files that end in '_test', pass the <code>--pattern='*_test.py'</code> argument. The reference section has more information on the different options you can pass to it.</p>

        <h3>Order of execution and parallelism</h3>

        <p>We talked about how batches and contexts are executed briefly, but it&rsquo;s now time to delve into it in more detail:</p>

        <pre class="brush:python">
@Vows.batch
class ReadFile(Vows.Context):
    def topic(self):
        return exists('some_file.txt')

    class AfterSuccessfullyReading(Vows.Context):
        def topic(self, exists):
            if exists:
                return open('some_file.txt').read()
            return None

        def if_exists_we_can_read_the_contents(self, topic):
            expect(topic).to_be_like('some string')
        </pre>

        <p>In the example above, we make use of nested contexts. As you can tell, the result of the parent topic is passed down to its children, as arguments.</p>

        <p>This example as a whole is therefore mostly sequential, while remaining asynchronous.</p>

        <hr />

        <p>Now let&rsquo;s look at an example which uses parallel tests to check for some devices:</p>

<pre class="brush:python">
@Vows.batch
class Exists(Vows.Context):
    class StdOut(Vows.Context):
        def topic(self):
            return exists('/dev/stdout')

        def exists(self, topic):
            expect(topic).to_be_true()

    class Tty(Vows.Context):
        def topic(self):
            return exists('/dev/tty')

        def exists(self, topic):
            expect(topic).to_be_true()

    class DevNull(Vows.Context):
        def topic(self):
            return exists('/dev/null')

        def exists(self, topic):
            expect(topic).to_be_true()
</pre>

        <p>So in this case, the tests can finish in any order, and must not rely on each other. The test suite will exit when the last I/O call completes, and the assertions for it are run.</p>

        <p>In other words, <em>sibling contexts</em> are executed in parallel, while <em>nested contexts</em> are executed sequentially. Note that this all happens asynchronously, so while some contexts may be waiting for a parent context to finish, sibling contexts can still execute in the meantime.</p>

        <h2>Context inheritance</h2>

        <p>pyVows context model allows for some interesting inheritance scenarios. Imagine we have the following method to test:</p>

        <pre class="brush:python">
def add(a, b):
    return a + b
        </pre>

        <p>We would write some vows as such:</p>

        <pre class="brush:python">
class Add(Vows.Context):
    def topic(self):
        return add(1, 2)

    def should_be_numeric(self, topic):
        expect(topic).to_be_numeric()

    def should_equal_to_three(self, topic):
        expect(topic).to_equal(3)
        </pre>

        <p>We might be writing redundant tests, but again, this is just an example. Now imagine we want to test for <strong>MANY</strong> different combinations. It would be very painful to write the exact same contexts and vows over and over just to test different values. Let's try writing the above in a different way:</p>

        <pre class="brush:python">
def addctx(a, b):
    class Context(Vows.Context):
        def topic(self):
            return add(a, b)

        def should_be_numeric(self, topic):
            expect(topic).to_be_numeric()

        def should_equal_to_three(self, topic):
            expect(topic).to_equal(a + b)

class AddEquals3(addctx(1,2)):
    pass

class AddEquals8(addctx(5,3)):
    pass

class AddEquals10(addctx(6,4)):
    pass

# and so on, and so forth
        </pre>

        <p>In the above test we are taking advantage of the functional nature of Python and returning a dynamic Context class as the result of <code>addctx</code>. This means that every time <code>addctx</code> is called it's returning a different Context that's aware of the values <code>a</code> and <code>b</code>.</p>

        <p>Context inheritance can also be a powerful tool to initialize database connections, web servers and any other resources your vows may rely on. A pretty good example of this is <a href="https://github.com/rafaelcaricio/tornado_pyvows">the tornado pyvows project</a> by <a href="https://github.com/rafaelcaricio">Rafael Carício</a>.</p>

        <h2>Using generative testing</h2>

        <p>Generative testing can be a great ally in having clean, lean tests. Let's get back to our old friend, the add two numbers example:</p>

        <pre class="brush:python">
def add(a, b):
    return a + b

class Add(Vows.Context):
    def topic(self):
        return add(1, 2)

    def should_be_numeric(self, topic):
        expect(topic).to_be_numeric()

    def should_equal_to_three(self, topic):
        expect(topic).to_equal(3)
        </pre>

        <p>Even though we can simplify this a lot by using context inheritance, like demonstrated in the previous section, we'll try something different now. We'll use generative testing.</p>

        <p>Generative testing is having a test (or in our case vows and contexts) be executed one or more times, but with different arguments (topics) in each pass.</p>

        <p>Let's rewrite the above using generative testing:</p>

        <pre class="brush:python">
def add(a, b):
    return a + b

test_data = [
    (1, 2, 3),
    (2, 5, 7),
    (3, 4, 7),
    (5, 6, 11)
]

class Add(Vows.Context):
    def topic(self):
        for item in test_data:
            a, b, c = item
            yield (add(a, b), c)

    def should_be_numeric(self, topic):
        sum, expected = topic
        expect(sum).to_be_numeric()

    def should_equal_to_expected(self, topic):
        sum, expected = topic
        expect(sum).to_equal(expected)
        </pre>

        <p>This means that <code>should_be_numeric</code> and <code>should_equal_to_expected</code> will be executed four times each with a tuple of two items: the result of adding a and b, and the expected result.</p>

        <p>Let's take this a step further and check against even more scenarios:</p>

        <pre class="brush:python">
 def add(a, b):
    return a + b

a_samples = range(10)
b_samples = range(10)

class Add(Vows.Context):
    class ATopic(Vows.Context):
        def topic(self):
            for a in a_samples:
                yield a

        class BTopic(Vows.Context):
            def topic(self, a):
                for b in b_samples:
                    yield b

            class Sum(Vows.Context):
                def topic(self, b, a):
                    yield (add(a, b), a + b)

                def should_be_numeric(self, topic):
                    sum, expected = topic
                    expect(sum).to_be_numeric()

                def should_equal_to_expected(self, topic):
                    sum, expected = topic
                    expect(sum).to_equal(expected)
        </pre>

        <p>This way we are verifying against the sum of all combinations of 0 to 9 plus 0 to 9, yet it is still very simple.</p>

        <p>Now we can add as many scenarios as we may think of, and won't have to write a single other vow.</p>

        <h2>Asynchronous Topics</h2>
        
        <p>Say you need to test an async method called <em>async_square</em> that takes a number and returns the square of that number, but asynchronously.</p>
        <p>Normally, you'd have a problem, since your tests would not wait for the callback (or even pass a callback for that matter). That's where <em>pyvows</em> comes to your rescue.</p>
        <p>Testing async topics is as easy as decorating the topic method with a <em>Vows.asyncTopic</em> decorator.</p>
        
        <pre class="brush:python">
 def async_square(a, callback):
    callback(a * a) # imagine this is async code and could take a while

class Square(Vows.Context):
    @Vows.asyncTopic
    def topic(self, callback):
        async_square(10, callback)
            
    def should_be_numeric(self, topic):
        expect(topic).to_be_numeric()

    def should_equal_to_expected(self, topic):
        expect(topic).to_equal(100)
        </pre>
        
        <p>Notice the <em>callback</em> argument in the topic. When you decorate the topic with <em>asyncTopic</em>, <em>pyvows</em> adds this argument.</p>
        <p>Simply pass this argument as the callback to the method you wish to test and let <em>pyvows</em> take care of the rest.</p>

        <h2>Assertions</h2>

        <p>pyVows features an extensible assertion model, with many useful functions, as well as error reporting.</p>

        <p>It&rsquo;s always best to use the more specific assertion functions when testing a value, you&rsquo;ll get much better error reporting, because your intention is clearer.</p>

        <p>Let&rsquo;s say we have the following array:</p>

        <pre class="brush:python">
ary = [1, 2, 3]
        </pre>

        <p>and try to assert that it has 5 elements. With the built-in <code>assert</code>, we would do something like this:</p>

        <pre class="brush:python">
assert len(ary) == 5
        </pre>

        <p>And get the following error:</p>

        <pre><code>AssertionError:</code></pre>

        <p>Now let&rsquo;s try that with one of our more specific assertion functions, <code>to_length</code>:</p>

        <pre class="brush:python">
expect(ary).to_length(5);
        </pre>

        <p>This reports the following error:</p>

        <pre><code>Expected topic([1, 2, 3]) to have 5 of length, but it had 3.</code></pre>

        <p>Other useful assertion functions bundled with pyVows include <code>to_match</code>, <code>to_be_instance_of</code>,
        <code>to_include</code> and <code>to_be_empty</code>&mdash;head over to the <a href="#reference">reference</a> to get the full list.</p>

        <h3>Custom Assertions</h3>

        <p>Creating new assertions to be used with <code>expect</code> is as simple as using the <code>Vows.create_assertions</code> decorator on a function that gets the topic as first parameter and the expectation as second:</p>

        <pre class="brush:python">
@Vows.create_assertions
def to_be_greater_than(topic, expected):
    return topic > expected
        </pre>

        <p>Now doing the following expectation:</p>

        <pre class="brush:python">
expect(2).to_be_greater_than(3);
        </pre>

        <p>Will report:</p>

        <pre><code>Expected topic(2) to be greater than 3.</code></pre>

        <p>It will also create the corresponding 'not_' assertion:</p>

        <pre class="brush:python">
expect(4).not_to_be_greater_than(3);
        </pre>

        <p>Will report:</p>

        <pre><code>Expected topic(4) not to be greater than 3.</code></pre>

        <p>If you need more control over your error message or your assertion doesn't have a corresponding 'not_', you can use the lower level <code>Vows.assertion</code> decorator and raise a <code>VowsAssertionError</code>. There are lots of examples <a href="https://github.com/heynemann/pyvows/tree/master/pyvows/assertions">here</a>.</p>

        <p>By raising a <code>VowsAssertionError</code> you get the benefit of highlighting the important values when your specs are giving error.</p>

        <p>If you still just wanna raise a <code>AssertionError</code>, like the old times, they are supported:</p>

        <pre class="brush:python">
# attention, this is not a recommendation, just an example of what could be done
@Vows.assertion
def to_be_a_positive_integer(topic):
    assert type(topic) == int, "Expected %s to be a positive integer, but it's not even an integer" % (topic,)
    assert topic != 0, "Expected %s to be a positive integer, but it's 0" % (topic,)
    assert topic > 0, "Expected %s to be a positive integer, but it is a negative integer" % (topic,)

@Vows.assertion
def not_to_be_a_positive_integer(topic):
    assert topic <= 0, "Expected %s not to be a positive integer, but it was" % (topic,)
        </pre>

        <p>It is really recommended to always declare the assertion and the 'not_' assertion (if applied), so they can be used like this:</p>
        <pre class="brush:python">
        expect(5).to_be_a_positive_integer()
        expect(-3).Not.to_be_a_positive_integer()
        </pre>
</section>

<section id="reference">
  <div class="content">
    <h1>Reference</h1>

<p>The runner and assertion modules are documented here.</p>

<h2>Test runner</h2>

<pre><code>pyvows [FILE, ...] [options]
</code></pre>

<p>Running specific tests</p>

<pre><code>$ pyvows test_1.py
$ pyvows tests/
</code></pre>

<p>Running all tests in the current or children folders</p>

<pre><code>$ pyvows
</code></pre>

<hr />

<h3>Options</h3>

<table cellspacing="10">
  <tr>
    <td class="usage"><code>-p</code>, <code>--pattern</code></td>
    <td>Pattern of files to run as vows. Defaults to "*_vows.py".</td>
  </tr>
  <tr>
    <td class="usage"><code>-c</code>, <code>--cover</code></td>
    <td>Indicates that coverage of code should be shown. Defaults to True.</td>
  </tr>
  <tr>
    <td class="usage"><code>-l</code>, <code>--cover_package</code></td>
    <td>Package to verify coverage. May be specified many times. Defaults to all packages.</td>
  </tr>
  <tr>
    <td class="usage"><code>-o</code>, <code>--cover_omit</code></td>
    <td>Path of file to exclude from coverage. May be specified many times. Defaults to no files.</td>
  </tr>
  <tr>
    <td class="usage"><code>-t</code>, <code>--cover_threshold</code></td>
    <td>Coverage number below which coverage is considered failing. Defaults to 80.0.</td>
  </tr>
  <tr>
    <td class="usage"><code>-r</code>, <code>--cover_report</code></td>
    <td>Store the coverage report as the specified file.</td>
  </tr>
  <tr>
    <td class="usage"><code>-x</code>, <code>--xunit_output</code></td>
    <td>Enable XUnit output.</td>
  </tr>
  <tr>
    <td class="usage"><code>-f</code>, <code>--xunit_file</code></td>
    <td>Filename of the XUnit output. Defaults to 'pyvows.xml'.</td>
  </tr>
  <tr>
    <td class="usage"><code>-v</code></td>
    <td>Verbosity. Can be supplied multiple times to increase verbosity. Defaults to -vv.</td>
  </tr>
  <tr>
    <td class="usage"><code>--no-color</code></td>
    <td>Does not colorize the output.</td>
  </tr>
  <tr>
    <td class="usage"><code>--help</code></td>
    <td>Show help</td>
  </tr>
  <tr>
    <td class="usage"><code>--version</code></td>
    <td>Show current installed pyvows' version</td>
  </tr>
</table>

<h2>Assertion functions</h2>

<h3>equality</h3>

<pre class="brush:python">
expect(4).to_equal(4)

expect(5).Not.to_equal(4)
</pre>

<h3>similarity</h3>

<pre class="brush:python">
expect("sOmE RandOm     CAse StRiNG").to_be_like('some random case string')

expect(1).to_be_like(1)
expect(1).to_be_like(1.0)
expect(1).to_be_like(long(1))

expect([1, 2, 3]).to_be_like([3, 2, 1])
expect([1, 2, 3]).to_be_like((3, 2, 1))
expect([[1, 2], [3,4]]).to_be_like([4, 3], [2, 1]])

expect({ 'some': 1, 'key': 2 }).to_be_like({ 'key': 2, 'some': 1 })

expect("sOmE RandOm     CAse StRiNG").Not.to_be_like('other string')
expect(1).Not_to_be_like(2)
expect([[1, 2], [3,4]]).Not.to_be_like([4, 4], [2, 1]])
expect({ 'some': 1, 'key': 2 }).Not.to_be_like({ 'key': 3, 'some': 4 })
</pre>


<h3>type</h3>

<pre class="brush:python">expect(os.path).to_be_a_function()
expect(1).to_be_numeric()

expect("some").Not.to_be_a_function()
expect("some").Not.to_be_numeric()
</pre>

<h3>truth</h3>

<pre class="brush:python">expect(True).to_be_true()
expect("some").to_be_true()
expect([1, 2, 3]).to_be_true()
expect({ "a": "b" }).to_be_true()
expect(1).to_be_true()

expect(False).to_be_false()
expect(None).to_be_false()
expect("").to_be_false()
expect(0).to_be_false()
expect([]).to_be_false()
expect({}).to_be_false()
</pre>

<h3>None</h3>

<pre class="brush:python">expect(None).to_be_null()
expect("some").Not.to_be_null()
</pre>

<h3>inclusion</h3>

<pre class="brush:python">expect([1, 2, 3]).to_include(2)
expect((1, 2, 3)).to_include(2)
expect("123").to_include("2")
expect({ "a": 1, "b": 2, "c": 3}).to_include("b")

expect([1, 3]).Not.to_include(2)
</pre>

<h3>regexp matching</h3>

<pre class="brush:python">expect('some').to_match(r'^[a-z]+')

expect("Some").Not.to_match(r'^[a-z]+')
</pre>

<h3>length</h3>

<pre class="brush:python">expect([1, 2, 3]).to_length(3)
expect((1, 2, 3)).to_length(3)
expect("abc").to_length(3)
expect({ "a": 1, "b": 2, "c": 3}).to_length(3)

expect([1]).Not.to_length(3)
</pre>

<h3>emptiness</h3>

<pre class="brush:python">expect([]).to_be_empty()
expect(tuple()).to_be_empty()
expect({}).to_be_empty()
expect("").to_be_empty()
</pre>

<h3>exceptions</h3>

<pre class="brush:python">expect(RuntimeError()).to_be_an_error()

expect(RuntimeError()).to_be_an_error_like(RuntimeError)

expect(ValueError("error")).to_have_an_error_message_of("error")

expect("I'm not an error").Not.to_be_an_error()

expect(ValueError()).Not.to_be_an_error_like(RuntimeError)

expect(ValueError("some")).Not.to_have_an_error_message_of("error")
</pre>

  </div>
</section>

<section id="about">
    <div class="content">
        <h1>About</h1>

        <p>Both pyVows and this website are <strong>HEAVILY</strong> inspired by the work done by <a href="http://cloudhead.io">Alexis Sellier</a>, more commonly known as <a href="http://cloudhead.io">cloudhead</a>. He is responsible for <a href="http://cloudhead.io/toto">toto</a>, <a href="http://github.com/cloudhead/less.js">LESS</a>, <a href="http://github.com/cloudhead/hijs">hijs</a>, and a lot more.</p>

        <p>More than that, he's responsible for a shift in the way we write tests. We have cleaner, leaner and meaner tests now. And they *ARE* fast.</p>

        <p>pyVows was developed by <a href="http://blog.heynemann.com.br" target="_blank">Bernardo Heynemann</a>, and features contribution by <a href="https://github.com/rafaelcaricio" target="_blank">Rafael Carício</a>, <a href="https://github.com/fabiomcosta">Fábio Costa</a> and <a href="https://github.com/truemped">Daniel Truemper</a>.</p>

        <p>The design for this website is the work of <a href="http://cloudhead.io">Alexis Sellier</a>, and this website is intended as a compliment and as recognition of his great work, not as a copy.</p>

        <footer>
            <p id="copy">Copyright &copy; Bernardo Heynemann 2011</p>
        </footer>
    </div>
</section>

    <a href="http://github.com/heynemann/pyvows"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://d3nwyuy0nl342s.cloudfront.net/img/bec6c51521dcc8148146135149fe06a9cc737577/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub"></a>

    <script src="./media/shCore.js" type="text/javascript"></script>
    <script src="./media/shBrushPython.js" type="text/javascript"></script>
    <script src="./media/shAutoloader.js" type="text/javascript"></script>
    <script type="text/javascript">
        SyntaxHighlighter.all()
    </script>
    <!--<script src="/media/hijs.js"></script>-->
  </body>
</html>

