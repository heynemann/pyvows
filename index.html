<!doctype html>
<html>
  <head>
    <link rel="alternate stylesheet" type="text/less" href="./media/main.less">
    <script src="./media/less.js" type="text/javascript"></script>
    <link href='http://fonts.googleapis.com/css?family=Droid+Serif' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Lobster' rel='stylesheet' type='text/css'>
    <link rel="alternate" type="application/atom+xml" title="app - feed" href="./index.xml" />
    <link href="./media/shThemeFadeToGrey.css" rel="stylesheet" type="text/css" />
    <style>
        .syntaxhighlighter {
            background-color: #191919 !important;
            border: dashed 1px #F9F9B3;
            padding: 8px;
        }
        .syntaxhighlighter .line.alt1,
        .syntaxhighlighter .line.alt2 {
            background-color: #191919 !important;
        }
        .syntaxhighlighter .toolbar {
            display: none;
        }
        .syntaxhighlighter .gutter .line {
            border-right: 3px solid #302D2C !important;
            text-align: center;
            padding-right: 7px;
        }

        .syntaxhighlighter.python code {
            background-color: #191919 !important;
        }

        .syntaxhighlighter .decorator, .syntaxhighlighter .decorator a {
            color: white !important;
        }

    </style>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <title>pyVows &laquo; Asynchronous BDD for Python</title>
    <script type="text/javascript">
      (function () {
          if (document.querySelectorAll) {
            window.onload = function () {
              var menu = document.getElementById('menu');
              var init = menu.offsetTop;
              var docked;

              var headers = document.querySelectorAll('#docs h2, #synopsis h2');

              for (var i = 0; i < headers.length; i++) {
                headers[i].id = '-' + headers[i].innerHTML.toLowerCase().replace(/ /g, '-');
              }

              window.onscroll = function () {
                if (!docked && (menu.offsetTop - scrollTop() < 0)) {
                  menu.style.top = 0;
                  menu.style.position = 'fixed';
                  menu.className = 'docked';
                  docked = true;
                } else if (docked && scrollTop() <= init) {
                  menu.style.position = 'absolute';
                  menu.style.top = init + 'px';
                  menu.className = menu.className.replace('docked', '');
                  docked = false;
                }
              };


              (function () {
                var link     = document.getElementById('guide-link'),
                    menu     = document.getElementById('menu'),
                    dropdown = document.getElementById('dropdown');

                link.onmouseover = function () {
                  link.className = 'dark-red';
                  dropdown.style.display = 'block';
                };
                link.onmouseout = function (e) {
                  if (e.relatedTarget === dropdown) { return }
                  link.className = link.className.replace('dark-red', '');
                  hide ();
                };
                dropdown.onmouseout = function (e) {
                  var t = e.relatedTarget;

                  if (e.target == link) { return }

                  while (t !== document.body) {
                    if (t == dropdown) { return }
                    else               { t = t.parentNode }
                  }
                  link.className = link.className.replace('dark-red', '');
                  hide ();
                };

                function hide() { dropdown.style.display = 'none' }
              })();
            };
          } else {
            alert('Please upgrade to a modern browser to view this site.');
          }

        function scrollTop() {
          return document.body.scrollTop || document.documentElement.scrollTop;
        }
      })();
    </script>
  </head>
  <body>
    <section>
      <header id="main">
  <div class="content">
    <section id="intro">
      <h1>pyVows</h1>
      <h2><span>Asynchronous</span> behaviour driven <span>development</span> for Python.</h2>
      <h3>
        The main reason for asynchronous testing is to make tests which target I/O
        run much faster, by running them concurrently. <br /><br />By having a faster suite, it gets run that more often,
        thus improving the feedback cycle.
      </h3>
    </section>

    <section id="example">
        <p>Write some vows, execute them:</p>
        <pre class="command">$ pyvows test/ </pre>
        <p>Get the report, make sure you kept your word.</p>
        <pre>A non-promise return value
  &#10003; <span class="vow">should be converted to a promise</span>
A topic not emitting an error
  &#10003; <span class="vow">should pass null if the test is expecting an error</span>
  &#10003; <span class="vow">should pass the result otherwise</span>
A topic emitting an error
  &#10003; <span class="vow">shouldn't raise an exception if the test expects it</span>
A context with a nested context
  &#10003; <span class="vow">has access to the environment</span>
  &#10003; <span class="vow">can make coffee</span>
A nested context
  &#10003; <span class="vow">should have access to the parent topics</span>
A nested context with no topics
  &#10003; <span class="vow">should pass the parent topics down</span>

&#10003; <span id="ok">OK</span> &#187; <strong>8</strong> honored &bull; <strong>0</strong> broken <span id="time">(0.112s)</span></pre>
    </section>
  </div>
  <div style="clear: both"></div>
</header>

<section id="menu">
  <div class="content">
    <nav>
      <a href="#intro">intro</a>
      <a href="#docs" id="guide-link">guide</a>
      <a href="#installing">installing</a>
      <a href="#reference">reference</a>
      <a href="#about">about</a>
      <a href="http://github.com/heynemann/pyvows">source <img id="github" src="./media/github.ico"/></a>
    </nav>
    <div id="dropdown">
      <ul>
        <li><a href="#-structure-of-a-test-batch">Structure of a Test Batch</a></li>
        <li><a href="#-how-topics-work">How topics work</a></li>
        <li><a href="#-running-a-suite">Running a Suite</a></li>
        <li><a href="#-assertions">Assertions</a></li>
      </ul>
    </div>
  </div>
</section>

<section id="synopsis">
    <div class="content">
        <h1>Synopsis</h1>

        <p>pyVows is a <a href="http://en.wikipedia.org/wiki/Behavior_Driven_Development">behavior driven development</a> framework for <a href="http://www.python.org">Python</a>.</p>

        <p>pyVows is inspired by <a href="http://vowsjs.org">Vows</a>, a BDD framework for node.js.</p>

        <p>Much of what's written here is based or the same as in <a href="http://vowsjs.org">Vows</a> docs.</p>

        <p>As its node.js counterpart, pyVows executes your tests in parallel when it makes sense,
        and sequentially when there are dependencies.</p>

        <p>Imagine we are testing a method that sums up two integers, like this:</p>

        <pre class="brush:python">
def test_sum_returns_42():
    result = add_two_numbers(41, 1)

    assert result
    assert int(result)
    assert result == 42
        </pre>

        <p>Even in a VERY simple scenario like this, we have three assertions in this test. Not too good if we want a single assertion per test, so we could do it like this:</p>

        <pre class="brush:python">
def test_sum_returns_result():
    result = add_two_numbers(41, 1)
    assert result

def test_sum_returns_a_number():
    result = add_two_numbers(41, 1)
    assert int(result)

def test_sum_returns_42():
    result = add_two_numbers(41, 1)
    assert result == 42
        </pre>

        <p>This is all fine and dandy, except that we are executing the add_two_numbers function three times. In this simple scenario we don't really care if it gets executed many times, but with real code we want to minimize calls so our tests are always as fast as possible.</p>

        <p>This is how the above test would look like in pyVows:</p>

        <pre class="brush:python">
class SumContext(Vows.Context):

    def topic(self):
        return add_two_numbers(41, 1)

    def we_get_a_result(self, topic):
        expect(topic).Not.to_be_null()

    def we_get_a_number(self, topic):
        expect(topic).to_be_numeric()

    def we_get_42(self, topic):
        expect(topic).to_equal(42)
        </pre>

        <p>Don't worry if you don't understand all of it. We'll see it more thoroughly in the next sections.</p>

        <p>Here&rsquo;s another example, this time describing &lsquo;division by zero&rsquo;:</p>

        <pre class="brush:python">
# division_by_zero_vows.py

from pyvows import Vows, expect

# Create a Test Batch
@Vows.batch
class Divisions(Vows.Context):
    class WhenDividingANumberByZero(Vows.Context):
        def topic(self):
            return 42 / 0

        def we_get_division_by_zero_error(self, topic):
            expect(topic).to_be_an_error_like(ZeroDivisionError)

    class WhenDividingByOne(Vows.Context):
        def topic(self):
            return 42 / 1

        def we_get_the_same_number(self, topic):
            expect(topic).to_equal(42)

        </pre>

        <p>And run it:</p>

        <pre><code>$ pyvows division_by_zero_vows.py</code></pre>

        <hr />

        <p>And now, a little more involved example&mdash;let&rsquo;s suppose we have a module called &lsquo;<code>the_good_things</code>&rsquo;, with some fruit in it:</p>

        <pre class="brush:python">
class Strawberry(object):
    def __init__(self):
        self.color = '#ff0000';

    def isTasty(self):
        return True

class PeeledBanana(object): pass

class Banana(object):
    def __init__(self):
        self.color = '#fff333';

    def peel(self):
        return PeeledBanana()
        </pre>

        <p>Now write some tests in <em>the_good_things_vows.py</em>:</p>

        <pre class="brush:python">
from pyvows import Vows, expect

from the_good_things import Strawberry, Banana, PeeledBanana

@Vows.batch
class TheGoodThings(Vows.Context):
    class AStrawberry(Vows.Context):
        def topic(self):
            return Strawberry()

        def is_red(self, topic):
            expect(topic.color).to_equal('#ff0000')

        def and_tasty(self, topic):
            expect(topic.isTasty()).to_be_true()

    class ABanana(Vows.Context):
        def topic(self):
            return Banana()

        class WhenPeeled(Vows.Context):
            def topic(self, banana):
                return banana.peel()

            def returns_a_peeled_banana(self, topic):
                expect(topic).to_be_instance_of(PeeledBanana)
        </pre>

        <p>And run them with the test runner:</p>

        <pre><code>$ pyvows the_good_things_vows.py</code></pre>

    </div>
</section>

<section id="installing">
    <div class="content">
        <h1>Installing</h1>

        <p>The easiest way to install pyVows, is via <a href="http://www.pip-installer.org/en/latest/index.html">pip</a>, the python package manager, as so:</p>

        <pre><code>$ pip install pyvows</code></pre>

        <p>Or to upgrade:</p>

        <pre><code>$ pip install -U pyvows</code></pre>
    </div>
</section>

<section id="docs">
    <div class="content">
        <h1>Guide</h1>

        <p>To understand pyVows, we&rsquo;re going to start with a general overview of the different components involved in writing tests, and then go through some of them in more detail.</p>

        <h2>Structure of a test batch</h2>

        <p>Test batches in pyVows are the largest unit of tests. The convention is to have one test batch per file, and have the batch&rsquo;s class match the file name. Test batches are created with <code>@Vows.batch</code> decorator.</p>

        <pre class="brush:python">
@Vows.batch
class MyTestVows(Vows.Context):
    pass
        </pre>

        <p>Tests are added to suites in <em>batches</em>. This is done with the <code>@Vows.batch</code> decorator.</p>

        <p>You can have as many batches in a suite as you want.</p>

        <p>Batches are <em>contexts</em>, that can in itself contain <em>contexts</em>, which describe different components and states you want to test.</p>

        <pre class="brush:python">
@Vows.batch
class AContext(Vows.Context):
    pass

@Vows.batch
class AnotherContext(Vows.Context):
    pass
        </pre>

        <p>Contexts are executed <em>in parallel</em>, and they are fully asynchronous. The order in which they finish is therefore undefined.</p>

        <p>Contexts usually contain <em>topics</em> and <em>vows</em>, which in combination define your tests.</p>

        <pre class="brush:python">
@Vows.batch
class AContext(Vows.Context):
    def topic(self):
        return "something"

    def i_am_a_vow(self, topic):
        # Test the results of the topic
        </pre>

<p>Contexts can contain <em>sub-contexts</em> which get executed as soon as the parent context finishes:</p>

        <pre class="brush:python">
@Vows.batch
class AContext(Vows.Context):
    def topic(self):
        return "something"

    def i_am_a_vow(self, topic):
        # Test the results of the topic

    class SubContext(Vows.Context):
        # Executed when AContext is done
        pass

@Vows.batch
class AnotherContext(Vows.Context):
    # Executed in Parallel to AContext
    pass
        </pre>

        <h3>Summary</h3>

        <p>» A <em>Suite</em> is a set of one or more <em>batches</em> that pyVows will execute.</p>

        <p>» A <em>batch</em> is a context, representing a structure of nested <em>contexts</em>.</p>

        <p>» A <em>context</em> is a class with an optional <em>topic</em>, zero or more <em>vows</em> and zero or more <em>sub-contexts</em>.</p>

        <p>» A <em>topic</em> is a function that returns a value.</p>

        <p>» A <em>vow</em> is a function which receives the <em>topic</em> as an argument, and runs an assertion on it.</p>

        <p>With that in mind, we can imagine the following grammar:</p>

        <pre><code>Suite   → Batch*
        Batch   → Context*
        Context → Topic? Vow* Context*
        </code></pre>

        <p>Here&rsquo;s an annotated example:</p>

        <pre class="brush:python">
@Vows.batch                                             # Batch
class Array(Vows.Context):                              # Context
    class AnArray(Vows.Context):                        # Sub-Context
        class WithThreeElements(Vows.Context):
            def topic(self):                            # Topic
                return [1, 2, 3]

            def has_length_of_3(self, topic):           # Vow
                expect(topic).to_length(3)              # Assertion

        class WithZeroElements(Vows.Context):           # Sub-Context
            def topic(self):                            # Topic
                return []

            def has_a_length_of_0(self, topic):         # Vow
                expect(topic).to_length(0)              # Assertion

            class WhenPopped(Vows.Context):
                def topic(self, previous_topic):
                    return previous_topic.pop()

                def raises_when_popped(self, topic):
                    expect(topic).to_be_an_error_like(IndexError)
        </pre>

        <h2>How topics work</h2>

        <p><a href="http://vowsjs.org" target="_blank">Vows</a> introduces an <strong>incredibly powerful</strong>, yet very simple way of writing your tests. pyVows leverages the same approach towards the same goals.</p>
        <p>Understanding <em>topics</em> is one of the keys to understanding pyVows. Unlike other testing frameworks, pyVows forces a clear separation between the element which is tested, the <em>topic</em>, and the actual tests, the <em>vows</em>.</p>

        <p>Let&rsquo;s start with a simple example of a context:</p>

        <pre class="brush:python">
class Test42(Vows.Context):
    def topic(self):
        return 42

    def should_be_equal_to_42(self, topic):
        expect(topic).to_equal(42)
        </pre>

        <p>So this shows us that the value of the topic is passed down to our test function (refered to as a <em>vow</em> from now on) as an argument.
        Simple enough. Now what if we have multiple vows?</p>

        <pre class="brush:python">
@Vows.batch
class Test42(Vows.Context):
    def topic(self):
        return 42

    def should_be_a_number(self, topic):
        expect(topic).to_be_numeric()

    def should_be_equal_to_42(self, topic):
        expect(topic).to_equal(42)
        </pre>

        <p>It works as expected, the value is passed down to each <em>vow</em>. Note that the topic function is <strong>only run once</strong>.</p>

        <h3>Scope</h3>

        <p>Sometimes, you might need a parent topic&rsquo;s value, from inside a child topic. This is easy, because there is a notion of topic <em>scope</em>. Let&rsquo;s look at an example:</p>

        <pre class="brush:python">
@Vows.batch
class DataStore(Vows.Context):
    def topic(self):
        return DataStore()

    def should_respond_to_get(self, store):
        expect(store.get).to_be_a_function()

    def should_respond_to_put(self, store):
        expect(store.put).to_be_a_function()

    class CallingGet(Vows.Context):
        def topic(self, store):
            return store.get(42)

        def should_return_the_object_with_id_42(self, topic):
            expect(topic.id).toEqual(42)
        </pre>

        <p>In the example above, the value of the top-level topic is passed as an argument to the inner topic, in the same manner it&rsquo;s passed to the vows. For clarity, I named both arguments which refer to the outer topic as <code>store</code>.</p>

        <p>Note that the scoping isn&rsquo;t limited to a single level. Consider:</p>

<pre class="brush:python">
def topic(self, a, b, c):
    # a being the Parent topic
    # b being the Parent of parent topic
    # c being the Parent of parent of parent topic

    # return something
</pre>

        <p>So the parent topics are passed along to each topic function in the certain order: the immediate parent is always the first argument (<code>a</code>), and the outer topics follow (<code>b</code>, then <code>c</code>), like the layers of an onion.</p>

        <h2>Running a suite</h2>

        <p>The simplest way to run a test suite, is with the <code>pyvows</code> command:</p>

<pre><code>pyvows vows/my_vows.py
</code></pre>

<p>The results will be printed to the console with the default reporter, which is <strong>very similar</strong> to <a href="http://vowsjs.org">Vows</a> <code>'dot-matrix'</code> reporter.</p>

        <h3>Running larger suites</h3>

        <p>When your tests become more complex, spanning multiple files, you&rsquo;re going to need a way to run them as a single entity.</p>

        <p>pyVows' test runner, can be used to run multiple test suites at once. To make use of it, just run it passing the directory as the argument, instead of the file, like this:</p>

        <pre><code>pyvows vows/</code></pre>

        <p>We can also pass options to <code>pyvows</code>. For example, to get pyvows to run only files that end in '_test', pass the <code>--pattern='*_test.py'</code> argument. The reference section has more information on the different options you can pass to it.</p>

        <h3>Order of execution and parallelism</h3>

        <p>We talked about how batches and contexts are executed briefly, but it&rsquo;s now time to delve into it in more detail:</p>

        <pre class="brush:python">
@Vows.batch
class ReadFile(Vows.Context):
    def topic(self):
        return exists('some_file.txt')

    class AfterSuccessfullyReading(Vows.Context):
        def topic(self, exists):
            if exists:
                return open('some_file.txt').read()
            return None
        
        def if_exists_we_can_read_the_contents(self, topic):
            expect(topic).to_be_like('some string')
        </pre>

        <p>In the example above, we make use of nested contexts. As you can tell, the result of the parent topic is passed down to its children, as arguments.</p>

        <p>This example as a whole is therefore mostly sequential, while remaining asynchronous.</p>

        <hr />

        <p>Now let&rsquo;s look at an example which uses parallel tests to check for some devices:</p>

<pre class="brush:python">
@Vows.batch
class Exists(Vows.Context):
    class StdOut(Vows.Context):
        def topic(self):
            return exists('/dev/stdout')

        def exists(self, topic):
            expect(topic).to_be_true()

    class Tty(Vows.Context):
        def topic(self):
            return exists('/dev/tty')

        def exists(self, topic):
            expect(topic).to_be_true()

    class DevNull(Vows.Context):
        def topic(self):
            return exists('/dev/null')

        def exists(self, topic):
            expect(topic).to_be_true()
</pre>

        <p>So in this case, the tests can finish in any order, and must not rely on each other. The test suite will exit when the last I/O call completes, and the assertions for it are run.</p>

        <p>In other words, <em>sibling contexts</em> are executed in parallel, while <em>nested contexts</em> are executed sequentially. Note that this all happens asynchronously, so while some contexts may be waiting for a parent context to finish, sibling contexts can still execute in the meantime.</p>

        <h2>Assertions</h2>

        <p>pyVows features an extensible assertion model, with many useful functions, as well as error reporting.</p>

        <p>It&rsquo;s always best to use the more specific assertion functions when testing a value, you&rsquo;ll get much better error reporting, because your intention is clearer.</p>

        <p>Let&rsquo;s say we have the following array:</p>

        <pre class="brush:python">
ary = [1, 2, 3]
        </pre>

        <p>and try to assert that it has 5 elements. With the built-in <code>assert</code>, we would do something like this:</p>

        <pre class="brush:python">
assert len(ary) == 5
        </pre>

        <p>And get the following error:</p>

        <pre><code>AssertionError:</code></pre>

        <p>Now let&rsquo;s try that with one of our more specific assertion functions, <code>to_length</code>:</p>

        <pre class="brush:python">
expect(ary).to_length(5);
        </pre>

        <p>This reports the following error:</p>

        <pre><code>Expected topic([1, 2, 3]) to have 5 of length, but it had 3</code></pre>

        <p>Other useful assertion functions bundled with pyVows include <code>to_match</code>, <code>to_be_instance_of</code>,
        <code>to_include</code> and <code>to_be_empty</code>&mdash;head over to the <a href="/#reference">reference</a> to get the full list.</p>

        <h3>Custom Assertions</h3>
        <p>Creating new assertions to be used with expect is as simple as using the <code>Vows.assertion</code> decorator on a function that gets topic as the first argument:</p>
        <pre class="brush:python">
@Vows.assertion
def to_be_greater_than(topic, expected):
    assert topic > expected, "Expected %s to be greather than %s, but it wasn't" % (topic, expected)

@Vows.assertion
def not_to_be_greater_than(topic, expected):
    assert topic <= expected, "Expected %s not to be greater than %s, but it was" % (topic, expected)
        </pre>
        <p>It is really important to always declare the assertion and the 'not_' assertion, so they can be used like this:</p>
        <pre class="brush:python">
        expect(5).to_be_greater_than(3)
        expect(3).Not.to_be_greater_than(5)
        </pre>
</section>

<section id="reference">
  <div class="content">
    <h1>Reference</h1>

<p>The runner and assertion modules are documented here.</p>

<h2>Test runner</h2>

<pre><code>pyvows [FILE, ...] [options]
</code></pre>

<p>Running specific tests</p>

<pre><code>$ pyvows test_1.py
$ pyvows tests/
</code></pre>

<p>Running all tests in the current or children folders</p>

<pre><code>$ pyvows
</code></pre>

<hr />

<h3>Options</h3>

<table cellspacing="10">
  <tr>
    <td><code>-p</code>, <code>--pattern</code></td>
    <td>Pattern of files to run as vows. Defaults to "*_vows.py".</td>
  </tr>
  <tr>
    <td><code>-s</code>, <code>--sequential</code></td>
    <td>Runs tests in sequential mode. Not recommended.</td>
  </tr>
  <tr>
    <td><code>--help</code></td>
    <td>Show help</td>
  </tr>
</table>

<h2>Assertion functions</h2>

<h3>equality</h3>

<pre class="brush:python">
expect(4).to_equal(4)

expect(5).Not.to_equal(4)
</pre>

<h3>similarity</h3>

<pre class="brush:python">
expect("sOmE RandOm     CAse StRiNG").to_be_like('some random case string')

expect(1).to_be_like(1)
expect(1).to_be_like(1.0)
expect(1).to_be_like(long(1))

expect([1, 2, 3]).to_be_like([3, 2, 1])
expect([1, 2, 3]).to_be_like((3, 2, 1))
expect([[1, 2], [3,4]]).to_be_like([4, 3], [2, 1]])

expect({ 'some': 1, 'key': 2 }).to_be_like({ 'key': 2, 'some': 1 })

expect("sOmE RandOm     CAse StRiNG").Not.to_be_like('other string')
expect(1).Not_to_be_like(2)
expect([[1, 2], [3,4]]).Not.to_be_like([4, 4], [2, 1]])
expect({ 'some': 1, 'key': 2 }).Not.to_be_like({ 'key': 3, 'some': 4 })
</pre>


<h3>type</h3>

<pre class="brush:python">expect(os.path).to_be_a_function()
expect(1).to_be_numeric()

expect("some").Not.to_be_a_function()
expect("some").Not.to_be_numeric()
</pre>

<h3>truth</h3>

<pre class="brush:python">expect(True).to_be_true()
expect("some").to_be_true()
expect([1, 2, 3]).to_be_true()
expect({ "a": "b" }).to_be_true()
expect(1).to_be_true()

expect(False).to_be_false()
expect(None).to_be_false()
expect("").to_be_false()
expect(0).to_be_false()
expect([]).to_be_false()
expect({}).to_be_false()
</pre>

<h3>None</h3>

<pre class="brush:python">expect(None).to_be_null()
expect("some").Not.to_be_null()
</pre>

<h3>inclusion</h3>

<pre class="brush:python">expect([1, 2, 3]).to_include(2)
expect((1, 2, 3)).to_include(2)
expect("123").to_include("2")
expect({ "a": 1, "b": 2, "c": 3}).to_include("b")

expect([1, 3]).Not.to_include(2)
</pre>

<h3>regexp matching</h3>

<pre class="brush:python">expect('some').to_match(r'^[a-z]+')

expect("Some").Not.to_match(r'^[a-z]+')
</pre>

<h3>length</h3>

<pre class="brush:python">expect([1, 2, 3]).to_length(3)
expect((1, 2, 3)).to_length(3)
expect("abc").to_length(3)
expect({ "a": 1, "b": 2, "c": 3}).to_length(3)

expect([1]).Not.to_length(3)
</pre>

<h3>emptiness</h3>

<pre class="brush:python">expect([]).to_be_empty()
expect(tuple()).to_be_empty()
expect({}).to_be_empty()
expect("").to_be_empty()
</pre>

<h3>exceptions</h3>

<pre class="brush:python">expect(RuntimeError()).to_be_an_error()

expect(RuntimeError()).to_be_an_error_like(RuntimeError)

expect(ValueError("error")).to_have_an_error_message_of("error")

expect(RuntimeError()).Not.to_be_an_error()

expect(RuntimeError()).Not.to_be_an_error_like(RuntimeError)

expect(ValueError("error")).Not.to_have_an_error_message_of("error")
</pre>

  </div>
</section>

<section id="about">
    <div class="content">
        <h1>About</h1>

        <p>Both pyVows and this website are <strong>HEAVILY</strong> inspired by the work done by <a href="http://cloudhead.io">Alexis Sellier</a>, more commonly known as <a href="http://cloudhead.io">cloudhead</a>. He is responsible for <a href="http://cloudhead.io/toto">toto</a>, <a href="http://github.com/cloudhead/less.js">LESS</a>, <a href="http://github.com/cloudhead/hijs">hijs</a>, and a lot more.</p>

        <p>More than that, he's responsible for a shift in the way we write tests. We have cleaner, leaner and meaner tests now. And they *ARE* fast.</p>

        <p>pyVows was developed by <a href="http://blog.heynemann.com.br" target="_blank">Bernardo Heynemann</a>, and features contribution by <a href="https://github.com/rafaelcaricio" target="_blank">Rafael Carício.</a></p>

        <p>The design for this website is the work of <a href="http://cloudhead.io">Alexis Sellier</a>, and this website is intended as a compliment and as recognition of his great work, not as a copy.</p>

        <footer>
            <p id="copy">Copyright &copy; Bernardo Heynemann 2011</p>
        </footer>
    </div>
</section>

    <a href="http://github.com/heynemann/pyvows"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://d3nwyuy0nl342s.cloudfront.net/img/bec6c51521dcc8148146135149fe06a9cc737577/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub"></a>

    <script src="./media/shCore.js" type="text/javascript"></script>
    <script src="./media/shBrushPython.js" type="text/javascript"></script>
    <script src="./media/shAutoloader.js" type="text/javascript"></script>
    <script type="text/javascript">
        SyntaxHighlighter.all()
    </script>
    <!--<script src="/media/hijs.js"></script>-->
  </body>
</html>

