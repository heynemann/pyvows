<!DOCTYPE html>
<!-- saved from url=(0018)http://vowsjs.org/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link rel="alternate stylesheet" type="text/less" href="http://vowsjs.org/less/main.less">
    <script src="./Vows « Asynchronous BDD for Node_files/less.js" type="text/javascript"></script><style type="text/css" media="" id="less:less-main">html {
  margin: 0;
}
body {
  background-color: #2a2522;
  margin: 0 auto;
  font-family: Arial, sans-serif;
  font-size: 100%;
  overflow-x: hidden;
}
nav,
header,
footer,
section,
article {
  display: block;
}
a {
  color: #b83000;
  text-decoration: none;
}
h1 a {
  color: black;
  text-decoration: none;
}
a:hover {
  text-decoration: underline;
}
h1,
h2,
h3,
h4 {
  margin: 0;
  font-weight: normal;
}
ul, li {
  list-style-type: none;
}
code {
  font-family: 'Bitstream Vera Sans Mono', 'DejaVu Sans Mono', 'Monaco', Courier, monospace !important;
}
code .string, code .regexp {
  color: #39532d;
}
code .keyword {
  font-weight: bold;
}
code .comment {
  color: rgba(0, 0, 0, 0.5);
}
code .number {
  color: #a33d29;
}
code .class, code .special {
  color: rgba(0, 50, 100, 0.8);
}
pre {
  padding: 0 30px;
  text-wrap: wrap;
  white-space: pre-wrap;
  /* css-3 */

  white-space: -moz-pre-wrap;
  /* Mozilla, since 1999 */

  white-space: -pre-wrap;
  /* Opera 4-6 */

  white-space: -o-pre-wrap;
  /* Opera 7 */

  word-wrap: break-word;
  /* Internet Explorer 5.5+ */

}
blockquote {
  font-style: italic;
}
body > footer {
  text-align: left;
  margin-left: 10px;
  font-style: italic;
  font-size: 18px;
  color: #888;
}
nav {
  margin-left: 15px;
}
nav a, #dropdown li {
  display: inline-block;
  color: white;
  line-height: 42px;
  margin: 0;
  padding: 0px 15px;
  text-shadow: -1px -1px 1px rgba(0, 0, 0, 0.5);
  text-decoration: none;
  border: 2px solid transparent;
  border-width: 0 2px;
}
nav a:hover, #dropdown li:hover {
  border: 2px solid #3d170f;
  border-left-color: #662619;
  border-right-color: #662619;
  border-bottom: 0;
  border-top: 0;
  background-color: #7a2e1f;
  text-decoration: none;
}
.dark-red {
  border: 2px solid #3d170f;
  border-left-color: #662619;
  border-right-color: #662619;
  border-bottom: 0;
  border-top: 0;
  background-color: #7a2e1f;
}
.content {
  margin: 0 auto;
  width: 960px;
}
#menu {
  position: absolute;
  width: 100%;
  z-index: 3;
  clear: both;
  display: block;
  background-color: #a33d29;
  height: 42px;
  border-top: 2px solid rgba(214, 112, 92, 0.5);
  border-bottom: 2px solid rgba(102, 38, 25, 0.5);
  box-shadow: 0 1px 8px rgba(0, 0, 0, 0.6);
  -moz-box-shadow: 0 1px 8px rgba(0, 0, 0, 0.6);
  -webkit-box-shadow: 0 1px 8px rgba(0, 0, 0, 0.6);
  -moz-box-shadow: 0 0 0 #000;
}
#menu.docked {
  background-color: rgba(163, 61, 41, 0.4);
}
#menu:hover {
  background-color: #a33d29;
}
#menu #dropdown {
  margin: 0 0 0 84px;
  padding: 0;
  padding-top: 5px;
  display: none;
  width: 190px;
  border-top: 2px solid #a33d29;
  color: #eaf2d9;
  border: 2px solid #3d170f;
  border-left-color: #662619;
  border-right-color: #662619;
  border-top-width: 0;
  background-color: #7a2e1f;
  border-radius: 5px;
  -moz-border-radius: 5px;
  -webkit-border-radius: 5px;
  border-top-right-radius: 0;
  border-top-left-radius: 0;
  -moz-border-top-right-radius: 0;
  -moz-border-top-left-radius: 0;
  -webkit-border-top-left-radius: 0;
  -webkit-border-top-right-radius: 0;
  box-shadow: 0 6px 8px rgba(0, 0, 0, 0.5);
  -moz-box-shadow: 0 6px 8px rgba(0, 0, 0, 0.5);
  -webkit-box-shadow: 0 6px 8px rgba(0, 0, 0, 0.5);
}
#menu #dropdown ul {
  padding: 0px;
}
#menu #dropdown li {
  font-size: 14px;
  display: block;
  text-align: left;
  padding: 0;
  border: 0;
}
#menu #dropdown li a {
  display: block;
  padding: 0px 15px;
  text-decoration: none;
  color: white;
}
#menu #dropdown li a:hover {
  background-color: #521f14;
  text-decoration: none;
}
hr {
  height: 6px;
  background-color: rgba(255, 255, 255, 0.1);
  margin: 30px 0;
  border: 0;
}
#main, #about, #docs {
  color: #2a2522;
  background-color: #bcd279;
}
#main pre,
#about pre,
#docs pre,
#main code,
#about code,
#docs code {
  border-color: #9fc653;
  background-color: #f4f9ec;
}
#main #intro, #about .content, #docs .content {
  background-color: #ecf2d9;
  box-shadow: 1px 0px 6px rgba(0, 0, 0, 0.5);
  -moz-box-shadow: 1px 0px 6px rgba(0, 0, 0, 0.5);
  -webkit-box-shadow: 1px 0px 6px rgba(0, 0, 0, 0.5);
}
#docs .content {
  border-top: 1px solid #bcd279;
  box-shadow: 0 5px 5px rgba(0, 0, 0, 0.4);
  -moz-box-shadow: 0 5px 5px rgba(0, 0, 0, 0.4);
  -webkit-box-shadow: 0 5px 5px rgba(0, 0, 0, 0.4);
}
#main {
  margin: 0 auto;
  width: 100%;
  border-top: 6px solid rgba(0, 0, 0, 0.1);
  font-family: 'Droid Serif', 'Georgia';
}
#main #intro {
  float: left;
  margin-top: -8px;
  height: 400px;
  position: relative;
  z-index: 2;
  width: 420px;
  padding: 45px 20px 23px 30px;
  border: 2px dashed #a9c653;
  border-bottom: 0;
  border-top: 0;
}
#main #intro h1 {
  text-shadow: 1px 1px 1px white;
  font-family: 'Lobster';
  color: #354c29;
  font-size: 96px;
  font-weight: normal;
}
#main #intro h2 {
  color: #405926;
  margin: 20px 0;
  font-size: 28px;
  line-height: 1.3em;
}
#main #intro h2 span {
  color: #a33d29;
}
#main #intro h3 {
  color: #405926;
  line-height: 1.4em;
  margin: 30px 0 15px 0;
  font-size: 1em;
  text-shadow: 0px 0px 0px #e6ebe0;
}
#main #example {
  float: right;
  font-size: 12px;
  width: 460px;
}
#main #example p {
  font-size: 16px;
  font-family: 'Helvetica', 'Arial', sans-serif;
  color: #405926;
  font-weight: bold;
  text-shadow: 0px 1px 1px #e6ebe0;
}
#main #example pre.command {
  padding: 15px 25px;
}
#main #example pre {
  text-shadow: 0 -1px 1px #221e1c;
  background-color: #272625;
  width: 400px;
  color: #ebefe7;
  background-repeat: repeat;
  padding: 25px;
  border: 1px dashed #e6ebe0;
  line-height: 15px;
  box-shadow: 0 0px 15px rgba(0, 0, 0, 0.5);
  -moz-box-shadow: 0 0px 15px rgba(0, 0, 0, 0.5);
  -webkit-box-shadow: 0 0px 15px rgba(0, 0, 0, 0.5);
  font-family: 'Bitstream Vera Sans Mono', 'DejaVu Sans Mono', 'Monaco', Courier, monospace !important;
  border-radius: 2px;
  -moz-border-radius: 2px;
  -webkit-border-radius: 2px;
  border-top-right-radius: 0;
  border-top-left-radius: 0;
  -moz-border-top-right-radius: 0;
  -moz-border-top-left-radius: 0;
  -webkit-border-top-left-radius: 0;
  -webkit-border-top-right-radius: 0;
  border-bottom-left-radius: 0;
  border-top-left-radius: 0;
  -moz-border-bottom-left-radius: 0;
  -moz-border-top-left-radius: 0;
  -webkit-border-bottom-left-radius: 0;
  -webkit-border-top-left-radius: 0;
}
#main #example pre .vow, #main #example pre #ok {
  color: #99c270;
}
#main #example pre .vow.pending {
  color: #669199;
}
#main #example pre #time {
  color: #aaaaaa;
}
.report pre .vow, .report pre #ok {
  color: #4d6b2e;
}
#synopsis,
#docs,
#reference,
#about,
#installing {
  margin: 0 auto;
  font-family: 'Georgia', serif;
  font-size: 18px;
  line-height: 24px;
  padding: 0 60px;
}
#synopsis .content,
#docs .content,
#reference .content,
#about .content,
#installing .content {
  width: 870px;
  padding: 45px;
}
#synopsis code,
#docs code,
#reference code,
#about code,
#installing code {
  font-size: 16px;
}
#synopsis p,
#docs p,
#reference p,
#about p,
#installing p {
  line-height: 26px;
}
#synopsis pre,
#docs pre,
#reference pre,
#about pre,
#installing pre,
#synopsis p > code,
#docs p > code,
#reference p > code,
#about p > code,
#installing p > code {
  padding: 0 3px;
  border-width: 1px;
  border-style: dashed;
}
#synopsis pre,
#docs pre,
#reference pre,
#about pre,
#installing pre {
  padding: 15px;
  margin: 15px 0;
  font-size: 16px;
}
#synopsis h1,
#docs h1,
#reference h1,
#about h1,
#installing h1 {
  font-size: 48px;
  font-family: 'Lobster';
  margin-top: 15px;
  margin-bottom: 30px;
}
#synopsis h2,
#docs h2,
#reference h2,
#about h2,
#installing h2 {
  font-family: 'Droid Serif', 'Georgia', serif;
  margin: 30px 0;
}
#synopsis p + h2,
#docs p + h2,
#reference p + h2,
#about p + h2,
#installing p + h2,
#synopsis pre + h2,
#docs pre + h2,
#reference pre + h2,
#about pre + h2,
#installing pre + h2,
#synopsis code + h2,
#docs code + h2,
#reference code + h2,
#about code + h2,
#installing code + h2 {
  border-top: 6px solid rgba(255, 255, 255, 0.1);
  padding-top: 30px;
}
#synopsis pre + h3,
#docs pre + h3,
#reference pre + h3,
#about pre + h3,
#installing pre + h3 {
  margin-top: 30px;
}
#synopsis h3,
#docs h3,
#reference h3,
#about h3,
#installing h3 {
  margin: 15px 0;
}
#about p + h2,
#docs p + h2,
#about pre + h2,
#docs pre + h2,
#about code + h2,
#docs code + h2 {
  border-top: 6px solid rgba(0, 0, 0, 0.1);
}
#about hr, #docs hr {
  background-color: rgba(0, 0, 0, 0.1);
}
#installing {
  color: #2a2522;
  background-color: #f8f89b;
}
#installing .content {
  clear: both;
  border-color: transparent;
  background-color: #fcfcd4;
  box-shadow: 0 5px 5px rgba(0, 0, 0, 0.4);
  -moz-box-shadow: 0 5px 5px rgba(0, 0, 0, 0.4);
  -webkit-box-shadow: 0 5px 5px rgba(0, 0, 0, 0.4);
}
#installing pre {
  background-color: #eaf2d9;
  border-color: #b9b90e;
}
#installing p + h2, #installing pre + h2, #installing code + h2 {
  border-top-color: rgba(0, 0, 0, 0.1);
}
td {
  padding-right: 30px;
}
#synopsis pre {
  padding: 20px;
  line-height: 18px;
  font-size: 14px;
}
#reference, #synopsis {
  text-shadow: 0 -1px 1px #191919;
  color: #eaf2d9;
  background-color: #191919;
}
#reference .content, #synopsis .content {
  background-color: #262626;
  clear: both;
  box-shadow: 0 5px 5px rgba(0, 0, 0, 0.4);
  -moz-box-shadow: 0 5px 5px rgba(0, 0, 0, 0.4);
  -webkit-box-shadow: 0 5px 5px rgba(0, 0, 0, 0.4);
}
#reference pre,
#synopsis pre,
#reference p > code,
#synopsis p > code {
  background-color: #191919;
  border-color: #f9f9b3;
}
#reference code .string,
#synopsis code .string,
#reference code .regexp,
#synopsis code .regexp {
  color: #b5c587;
}
#reference code .keyword, #synopsis code .keyword {
  color: #c2a770;
  font-weight: normal;
}
#reference code .comment, #synopsis code .comment {
  color: rgba(255, 255, 255, 0.2);
}
#reference code .number, #synopsis code .number {
  color: #a33d29;
}
#reference code .class,
#synopsis code .class,
#reference code .special,
#synopsis code .special {
  color: #669199;
}
#reference a, #synopsis a {
  color: #fbfbcb;
  border-bottom: 1px dashed rgba(255, 255, 255, 0.2);
}
#reference a:hover, #synopsis a:hover {
  text-decoration: none;
  border-bottom: 1px dashed #fbfbcb;
}
#synopsis {
  padding-top: 30px;
  background-color: #2a2522 !important;
}
#synopsis .content {
  background-color: #302d2c;
}
#about footer {
  margin-top: 30px;
  padding-top: 30px;
  border-top: 6px solid rgba(0, 0, 0, 0.1);
  text-align: center;
  font-size: 16px;
  color: rgba(0, 0, 0, 0.4);
}
#about footer #copy {
  font-size: 12px;
}
#github {
  width: 14px;
  background-color: rgba(255, 255, 255, 0.7);
  box-shadow: -1px -1px 1px rgba(0, 0, 0, 0.5);
  -moz-box-shadow: -1px -1px 1px rgba(0, 0, 0, 0.5);
  -webkit-box-shadow: -1px -1px 1px rgba(0, 0, 0, 0.5);
  padding: 0 1px;
  margin-left: 2px;
  border-radius: 2px;
  -moz-border-radius: 2px;
  -webkit-border-radius: 2px;
}
</style>
    <link href="./Vows « Asynchronous BDD for Node_files/css" rel="stylesheet" type="text/css">
    <link href="./Vows « Asynchronous BDD for Node_files/css(1)" rel="stylesheet" type="text/css">
    <link rel="alternate" type="application/atom+xml" title="app - feed" href="http://vowsjs.org/index.xml">
    
    <title>Vows « Asynchronous BDD for Node</title>
    <script type="text/javascript">
      (function () {
          if (document.querySelectorAll) {
            window.onload = function () {
              var menu = document.getElementById('menu');
              var init = menu.offsetTop;
              var docked;

              var headers = document.querySelectorAll('#docs h2, #synopsis h2');

              for (var i = 0; i < headers.length; i++) {
                headers[i].id = '-' + headers[i].innerHTML.toLowerCase().replace(/ /g, '-');
              }

              window.onscroll = function () {
                if (!docked && (menu.offsetTop - scrollTop() < 0)) {
                  menu.style.top = 0;
                  menu.style.position = 'fixed';
                  menu.className = 'docked';
                  docked = true;
                } else if (docked && scrollTop() <= init) {
                  menu.style.position = 'absolute';
                  menu.style.top = init + 'px';
                  menu.className = menu.className.replace('docked', '');
                  docked = false;
                }
              };


              (function () {
                var link     = document.getElementById('guide-link'),
                    menu     = document.getElementById('menu'),
                    dropdown = document.getElementById('dropdown');

                link.onmouseover = function () {
                  link.className = 'dark-red';
                  dropdown.style.display = 'block';
                };
                link.onmouseout = function (e) {
                  if (e.relatedTarget === dropdown) { return }
                  link.className = link.className.replace('dark-red', '');
                  hide ();
                };
                dropdown.onmouseout = function (e) {
                  var t = e.relatedTarget;

                  if (e.target == link) { return }

                  while (t !== document.body) {
                    if (t == dropdown) { return }
                    else               { t = t.parentNode }
                  } 
                  link.className = link.className.replace('dark-red', '');
                  hide ();
                };

                function hide() { dropdown.style.display = 'none' }
              })();
            };
          } else {
            alert('Please upgrade to a modern browser to view this site.');
          }

        function scrollTop() {
          return document.body.scrollTop || document.documentElement.scrollTop;
        }
      })();
    </script>
  </head>
  <body>
    <section>
      <header id="main">
  <div class="content">
    <section id="intro">
      <h1>Vows</h1>
      <h2><span>Asynchronous</span> behaviour driven <span>development</span> for Node.</h2>
      <h3>
        There are two reasons why we might want asynchronous testing.
        The first, and obvious reason is that node.js is asynchronous,
        and therefore our tests should be. The second reason is to make tests which target I/O
        run much faster, by running them concurrently.
      </h3>
    </section>

    <section id="example">
        <p>Write some vows, execute them:</p>
        <pre class="command">$ vows test/* --spec</pre>
        <p>Get the report, make sure you kept your word.</p>
        <pre>A non-promise return value
  ✓ <span class="vow">should be converted to a promise</span>
A topic not emitting an error
  ✓ <span class="vow">should pass null if the test is expecting an error</span>
  ✓ <span class="vow">should pass the result otherwise</span>
A topic emitting an error
  ✓ <span class="vow">shouldn't raise an exception if the test expects it</span>
A context with a nested context
  ✓ <span class="vow">has access to the environment</span>
  - <span class="vow pending">can make coffee</span>
A nested context
  ✓ <span class="vow">should have access to the parent topics</span>
A nested context with no topics
  ✓ <span class="vow">should pass the parent topics down</span>
 
✓ <span id="ok">OK</span> » <strong>7</strong> honored • <strong>1</strong> pending <span id="time">(0.112s)</span></pre>
    </section>
  </div>
  <div style="clear: both"></div>
</header>

<section id="menu" style="position: absolute; top: 466px; " class="">
  <div class="content">
    <nav>
      <a href="http://vowsjs.org/#intro">intro</a>
      <a href="http://vowsjs.org/#docs" id="guide-link">guide</a>
      <a href="http://vowsjs.org/#installing">installing</a>
      <a href="http://vowsjs.org/#reference">reference</a>
      <a href="http://vowsjs.org/#about">about</a>
      <a href="http://github.com/cloudhead/vows">source <img id="github" src="./Vows « Asynchronous BDD for Node_files/github.ico"></a>
    </nav>
    <div id="dropdown">
      <ul>
        <li><a href="http://vowsjs.org/#-structure-of-a-test-suite">Structure of a Test Suite</a></li>
        <li><a href="http://vowsjs.org/#-how-topics-work">How topics work</a></li>
        <li><a href="http://vowsjs.org/#-running-a-suite">Running a Suite</a></li>
        <li><a href="http://vowsjs.org/#-writing-asynchronous-tests">Asynchronous Testing</a></li>
        <li><a href="http://vowsjs.org/#-assertions">Assertions</a></li>
        <li><a href="http://vowsjs.org/#-macros">Macros</a></li>
      </ul>
    </div>
  </div>
</section>

<section id="synopsis">
  <div class="content">
    <h1>Synopsis</h1>

<p>Vows is a <a href="http://en.wikipedia.org/wiki/Behavior_Driven_Development">behavior driven development</a>
framework for <a href="http://nodejs.org/">Node.js</a>.</p>

<p>Vows was built from the ground up to test asynchronous code. It executes your tests in parallel when it makes sense,
and sequentially when there are dependencies.</p>

<p>Emphasis was put on speed of execution, clarity and user experience.</p>

<p>Here’s a simple example, describing ‘division by zero’:</p>

<pre><code><span class="comment">// division-by-zero-test.js</span>

<span class="keyword">var</span> vows = require(<span class="string">'vows'</span>),
    assert = require(<span class="string">'assert'</span>);

<span class="comment">// Create a Test Suite</span>
vows.describe(<span class="string">'Division by Zero'</span>).addBatch({
    <span class="string">'when dividing a number by zero'</span>: {
        topic: <span class="keyword">function</span> () { <span class="keyword">return</span> <span class="number">42</span> / <span class="number">0</span> },

        <span class="string">'we get Infinity'</span>: <span class="keyword">function</span> (topic) {
            assert.equal (topic, <span class="class">Infinity</span>);
        }
    },
    <span class="string">'but when dividing zero by zero'</span>: {
        topic: <span class="keyword">function</span> () { <span class="keyword">return</span> <span class="number">0</span> / <span class="number">0</span> },

        <span class="string">'we get a value which'</span>: {
            <span class="string">'is not a number'</span>: <span class="keyword">function</span> (topic) {
                assert.isNaN (topic);
            },
            <span class="string">'is not equal to itself'</span>: <span class="keyword">function</span> (topic) {
                assert.notEqual (topic, topic);
            }
        }
    }
}).run(); <span class="comment">// Run it</span>
</code></pre>

<p>And run it:</p>

<pre><code>$ node division-by-zero-test.js
</code></pre>

<hr>

<p>And now, a little more involved example—let’s suppose we have a module called ‘<code>the-good-things</code>’, with some fruit constructors
in it:</p>

<pre><code>exports.<span class="class">Strawberry</span> = <span class="keyword">function</span> () {
    <span class="keyword">this</span>.color = <span class="string">'#ff0000'</span>;
};
exports.<span class="class">Strawberry</span>.prototype = {
    isTasty: <span class="keyword">function</span> () { <span class="keyword">return</span> <span class="keyword">true</span> }
};

exports.<span class="class">Banana</span> = <span class="keyword">function</span> () {
    <span class="keyword">this</span>.color = <span class="string">'#fff333'</span>;
};
exports.<span class="class">Banana</span>.prototype = {
    peel: <span class="keyword">function</span> (callback) {
        process.nextTick(<span class="keyword">function</span> () {
            callback(<span class="keyword">null</span>, <span class="keyword">new</span>(exports.<span class="class">PeeledBanana</span>));
        });
    },
    peelSync: <span class="keyword">function</span> () { <span class="keyword">return</span> <span class="keyword">new</span>(exports.<span class="class">PeeledBanana</span>) }
};

exports.<span class="class">PeeledBanana</span> = <span class="keyword">function</span> () {};
</code></pre>

<p>Now write some tests in <em>the-good-things-test.js</em>:</p>

<pre><code><span class="keyword">var</span> vows = require(<span class="string">'vows'</span>),
    assert = require(<span class="string">'assert'</span>);

<span class="keyword">var</span> theGoodThings = require(<span class="string">'the-good-things'</span>);

<span class="keyword">var</span> <span class="class">Strawberry</span>   = theGoodThings.<span class="class">Strawberry</span>,
    <span class="class">Banana</span>       = theGoodThings.<span class="class">Banana</span>,
    <span class="class">PeeledBanana</span> = theGoodThings.<span class="class">PeeledBanana</span>;

vows.describe(<span class="string">'The Good Things'</span>).addBatch({
    <span class="string">'A strawberry'</span>: {
        topic: <span class="keyword">new</span>(<span class="class">Strawberry</span>),

        <span class="string">'is red'</span>: <span class="keyword">function</span> (strawberry) {
            assert.equal (strawberry.color, <span class="string">'#ff0000'</span>);
        },
        <span class="string">'and tasty'</span>: <span class="keyword">function</span> (strawberry) {
            assert.isTrue (strawberry.isTasty());
        }
    },
    <span class="string">'A banana'</span>: {
        topic: <span class="keyword">new</span>(<span class="class">Banana</span>),

        <span class="string">'when peeled *synchronously*'</span>: {
            topic: <span class="keyword">function</span> (banana) {
                <span class="keyword">return</span> banana.peelSync();
            },
            <span class="string">'returns a `PeeledBanana`'</span>: <span class="keyword">function</span> (result) {
                assert.instanceOf (result, <span class="class">PeeledBanana</span>);
            }
        },
        <span class="string">'when peeled *asynchronously*'</span>: {
            topic: <span class="keyword">function</span> (banana) {
                banana.peel(<span class="keyword">this</span>.callback);
            },
            <span class="string">'results in a `PeeledBanana`'</span>: <span class="keyword">function</span> (err, result) {
                assert.instanceOf (result, <span class="class">PeeledBanana</span>);
            }
        }
    }
}).export(module); <span class="comment">// Export the Suite</span>
</code></pre>

<p>And run them with the test runner:</p>

<pre><code>$ vows the-good-things-test.js
</code></pre>

  </div>
</section>

<section id="installing">
  <div class="content">
    <h1>Installing</h1>

<p>The easiest way to install Vows, is via <a href="http://github.com/isaacs/npm">npm</a>, the node package manager, as so:</p>

<pre><code>$ npm install vows
</code></pre>

<p>This will get you the latest stable version. If you want the bleeding edge, try:</p>

<pre><code>$ npm install vows@latest
</code></pre>

  </div>
</section>

<section id="docs">
  <div class="content">
      <h1>Guide</h1>

<p>To understand Vows, we’re going to start with a general overview of the different components involved in writing tests,
and then go through some of them in more detail.</p>

<h2 id="-structure-of-a-test-suite">Structure of a test suite</h2>

<p>Test suites in Vows are the largest unit of tests. The convention is to have one test suite
per file, and have the suite’s subject match the file name. Test suites are created with <code>vows.describe</code>.</p>

<pre><code><span class="keyword">var</span> suite = vows.describe(<span class="string">'subject'</span>);
</code></pre>

<p>Tests are added to suites in <em>batches</em>. This is done with the <code>addBatch</code> method.</p>

<pre><code>suite.addBatch({});
</code></pre>

<p>You can add as many batches to a suite as you want. Batches are executed <em>sequentially</em>.</p>

<pre><code>suite.addBatch({<span class="comment">/* run 1st */</span>}).addBatch({<span class="comment">/* 2nd */</span>}).addBatch({<span class="comment">/* 3rd */</span>});
</code></pre>

<p>Chaining batches is useful when you want to test functionality in a certain order.</p>

<p>Batches contain <em>contexts</em>, which describe different components and states you want to test.</p>

<pre><code>suite.addBatch({
   <span class="string">'A context'</span>: {},
   <span class="string">'Another context'</span>: {}
});
</code></pre>

<p>Contexts are executed <em>in parallel</em>, they are fully asynchronous. The order in which they finish is therefore undefined.</p>

<p>Contexts usually contain <em>topics</em> and <em>vows</em>, which in combination define your tests.</p>

<pre><code>suite.addBatch({
   <span class="string">'A context'</span>: {
        topic: <span class="keyword">function</span> () {<span class="comment">/* Do something async */</span>},
        <span class="string">'I am a vow'</span>: <span class="keyword">function</span> (topic) {
            <span class="comment">/* Test the result of the topic */</span>
        }
    },
   <span class="string">'Another context'</span>: {}
});
</code></pre>

<p>Contexts can contain <em>sub-contexts</em> which get executed as soon as the parent context finishes:</p>

<pre><code>suite.addBatch({
   <span class="string">'A context'</span>: {
       topic: <span class="keyword">function</span> () {<span class="comment">/* Do something async */</span>},
       <span class="string">'I am a vow'</span>: <span class="keyword">function</span> (topic) {
           <span class="comment">/* Test the result of the topic */</span>
       },
       <span class="string">'A sub-context'</span>: {
           <span class="comment">/* Executed when the tests above finish running */</span>
       }
   },
   <span class="string">'Another context'</span>: {
       <span class="comment">/* Executed in parallel to 'A context' */</span>
    }
});
</code></pre>

<h3>Summary</h3>

<p>» A <em>Suite</em> is an object which contains zero or more <em>batches</em>, and can be executed or exported.</p>

<p>» A <em>batch</em> is an object literal, representing a structure of nested <em>contexts</em>.</p>

<p>» A <em>context</em> is an object with an optional <em>topic</em>, zero or more <em>vows</em> and zero or more <em>sub-contexts</em>.</p>

<p>» A <em>topic</em> is either a value or a function which can execute asynchronous code.</p>

<p>» A <em>vow</em> is a function which receives the <em>topic</em> as an argument, and runs assertions on it.</p>

<p>With that in mind, we can imagine the following grammar:</p>

<pre><code><span class="class">Suite</span>   → <span class="class">Batch</span>*
<span class="class">Batch</span>   → <span class="class">Context</span>*
<span class="class">Context</span> → <span class="class">Topic</span>? <span class="class">Vow</span>* <span class="class">Context</span>*
</code></pre>

<p>Here’s an annotated example:</p>

<pre><code>vows.describe(<span class="string">'Array'</span>).addBatch({                      <span class="comment">// Batch</span>
    <span class="string">'An array'</span>: {                                      <span class="comment">// Context</span>
        <span class="string">'with 3 elements'</span>: {                           <span class="comment">// Sub-Context</span>
            topic: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],                          <span class="comment">// Topic</span>

            <span class="string">'has a length of 3'</span>: <span class="keyword">function</span> (topic) {    <span class="comment">// Vow</span>
                assert.equal(topic.length, <span class="number">3</span>);
            }
        },
        <span class="string">'with zero elements'</span>: {                        <span class="comment">// Sub-Context</span>
            topic: [],                                 <span class="comment">// Topic</span>

            <span class="string">'has a length of 0'</span>: <span class="keyword">function</span> (topic) {    <span class="comment">// Vow</span>
                assert.equal(topic.length, <span class="number">0</span>);
            },
            <span class="string">'returns *undefined*, when `pop()`ed'</span>: <span class="keyword">function</span> (topic) {
                assert.isUndefined(topic.pop());
            }
        }
    }
});
</code></pre>

<h2 id="-how-topics-work">How topics work</h2>

<p>Understanding <em>topics</em> is one of the keys to understanding Vows. Unlike other testing frameworks,
Vows forces a clear separation between the element which is tested, the <em>topic</em>, and the actual tests, the <em>vows</em>.</p>

<p>Let’s start with a simple example of a context:</p>

<pre><code>{ topic: <span class="number">42</span>,
  <span class="string">'should be equal to 42'</span>: <span class="keyword">function</span> (topic) {
    assert.equal (topic, <span class="number">42</span>);
  }
}
</code></pre>

<p>So this shows us that the value of the topic is passed down to our test function (refered to as a <em>vow</em> from now on) as an argument.
Simple enough. Now let’s look at an equivalent example, written differently:</p>

<pre><code>{ topic: <span class="keyword">function</span> () { <span class="keyword">return</span> <span class="number">42</span> },
  <span class="string">'should be equal to 42'</span>: <span class="keyword">function</span> (topic) {
    assert.equal (topic, <span class="number">42</span>);
  }
}
</code></pre>

<p>Same thing. Topics can be functions too. The return value becomes the topic. Now what if we have multiple vows?</p>

<pre><code>{ topic: <span class="keyword">function</span> () { <span class="keyword">return</span> <span class="number">42</span> },
  <span class="string">'should be a number'</span>: <span class="keyword">function</span> (topic) {
    assert.isNumber (topic);
  },
  <span class="string">'should be equal to 42'</span>: <span class="keyword">function</span> (topic) {
    assert.equal (topic, <span class="number">42</span>);
  }
}
</code></pre>

<p>It works as expected, the value is passed down to each <em>vow</em>. Note that the topic function is <strong>only run once</strong>.</p>

<h3>Scope</h3>

<p>Sometimes, you might need a parent topic’s value, from inside a child topic. This is easy, because there is
a notion of topic <em>scope</em>. Let’s look at an example:</p>

<pre><code>{ topic: <span class="keyword">new</span>(<span class="class">DataStore</span>),
  <span class="string">'should respond to `get()` and `put()`'</span>: <span class="keyword">function</span> (store) {
    assert.isFunction (store.get);
    assert.isFunction (store.put);
  },
  <span class="string">'calling `get(42)`'</span>: {
    topic: <span class="keyword">function</span> (store) { <span class="keyword">return</span> store.get(<span class="number">42</span>) },
    <span class="string">'should return the object with id 42'</span>: <span class="keyword">function</span> (topic) {
      assert.equal (topic.id, <span class="number">42</span>);
    }
  }
}
</code></pre>

<p>In the example above, the value of the top-level topic is passed as an argument to the inner topic, in the same manner
it’s passed to the vows. For clarity, I named both arguments which refer to the outer topic as <code>store</code>.</p>

<p>Note that the scoping isn’t limited to a single level. Consider:</p>

<pre><code>topic: <span class="keyword">function</span> (a, <span class="comment">/* Parent topic                     */</span>
                 b, <span class="comment">/* Parent of parent topic           */</span>
                 c  <span class="comment">/* Parent of parent of parent topic */</span>) {}
</code></pre>

<p>So the parent topics are passed along to each topic function in the certain order: the immediate parent is always the first
argument (<code>a</code>), and the outer topics follow (<code>b</code>, then <code>c</code>), like the layers of an onion.</p>

<h2 id="-running-a-suite">Running a suite</h2>

<p>The simplest way to run a test suite, is with the <code>run</code> method:</p>

<pre><code>vows.describe(<span class="string">'subject'</span>).addBatch({<span class="comment">/* ... */</span>}).run();
</code></pre>

<p>The <code>run</code> method takes an optional callback, which is called when all tests are done running.
The test results are passed to the callback (if provided), as an object:</p>

<pre><code>{ honored: <span class="number">145</span>,
  broken:    <span class="number">4</span>,
  errored:   <span class="number">1</span>,
  pending:   <span class="number">0</span>,
  total:   <span class="number">150</span>,
  time:  <span class="number">5.491</span>
};
</code></pre>

<p>Now if we want to execute this test suite, assuming it’s in <em>subject-test.js</em>, we just do:</p>

<pre><code>$ node subject-test.js
</code></pre>

<p>The results will be printed to the console with the default reporter, <code><span class="string">'dot-matrix'</span></code>.</p>

<h3>Exporting the suite</h3>

<p>When your tests become more complex, spanning multiple files, you’re going to need a way to run
them as a single entity.</p>

<p>Vows has a test runner called <code>vows</code>, which you can use to run multiple test suites at once.
To make use of it, you need to export your tests, instead of just running them. There’s a couple
of ways to do that, the easiest is through the <code>export</code> method:</p>

<pre><code><span class="comment">// subject-test.js</span>

vows.describe(<span class="string">'subject'</span>).addBatch({<span class="comment">/* ... */</span>}).export(module);
</code></pre>

<p><code>export</code> takes one argument, the module you want to export the test suite to. Fortunately,
node provides a global variable called <code>module</code>, which is a reference to the current module.</p>

<p>Now to run that file with the test runner, we can do:</p>

<pre><code>$ vows subject-test.js
</code></pre>

<p>The result should be identical to running it directly with <code>node</code>. The difference is that we can now do:</p>

<pre><code>$ vows test/*
</code></pre>

<p>to run all the tests in our <em>test/</em> folder, and get combined results. We can also pass options to <code>vows</code>.
For example, to get a “spec style” output, pass the <code>--spec</code> flag. The reference section has more information on
the different options you can pass to it.</p>

<p>Another way to export your test suites is by simply adding them to the <code>exports</code> object, the same way you would export
an API to a library:</p>

<pre><code>exports.suite1 = vows.describe(<span class="string">'suite one'</span>);
exports.suite2 = vows.describe(<span class="string">'suite two'</span>);
</code></pre>

<h3>So let’s recap</h3>

<pre><code><span class="comment">// subject-test.js</span>
<span class="comment">// A test suite, describing 'subject'</span>

vows.describe(<span class="string">'subject'</span>) <span class="comment">// Create the suite, describing 'subject'</span>
    .addBatch({})        <span class="comment">// Add the 1st batch</span>
    .addBatch({})        <span class="comment">// Add a 2nd batch</span>
    .addBatch({})        <span class="comment">// Add a 3rd batch</span>
    .export(module);     <span class="comment">// Export it</span>
</code></pre>

<h2 id="-writing-asynchronous-tests">Writing asynchronous tests</h2>

<blockquote><p>Before diving into asynchronous testing, make sure you read the section about <em>topics</em>.</p></blockquote>

<p>Let’s say we want to test that a certain file exists, and satisfies a couple criteria.</p>

<p>As you know, we don’t ‘return’ a value from an asynchronous function call—the value is
passed to the callback function. So how can we do that with <em>topics</em>? Take a look:</p>

<pre><code>{ topic: <span class="keyword">function</span> () {
    fs.stat(<span class="string">'~/FILE'</span>, <span class="keyword">this</span>.callback);
  },
  <span class="string">'can be accessed'</span>: <span class="keyword">function</span> (err, stat) {
    assert.isNull   (err);        <span class="comment">// We have no error</span>
    assert.isObject (stat);       <span class="comment">// We have a stat object</span>
  },
  <span class="string">'is not empty'</span>: <span class="keyword">function</span> (err, stat) {
    assert.isNotZero (stat.size); <span class="comment">// The file size is &gt; 0</span>
  }
}
</code></pre>

<p>The key here is the special ‘<code><span class="keyword">this</span>.callback</code>’ function, which is available inside all topics.</p>

<p>When <code><span class="keyword">this</span>.callback</code> is <em>called</em>, it passes on the arguments it received to the test functions,
one by one, as if the values were returned by the topic function itself.</p>

<p>In essence, this allows us to decouple the callback from the async function call.</p>

<p>This is how Vows keeps track of all the asynchronous calls, and can warn you if something
hasn’t returned.</p>

<blockquote><p>Note that topics which make use of ‘<code><span class="keyword">this</span>.callback</code>’ must not return anything. And likewise, topics
which do not return anything must make use of ‘<code><span class="keyword">this</span>.callback</code>’.</p></blockquote>

<h3>Promises</h3>

<p>Vows also supports promise-based async out of the box, so if that works better for your purpose,
you can return an instance of <code><span class="class">EventEmitter</span></code> from a topic, and the tests will be run when it
emits a <code><span class="string">"success"</span></code> or <code><span class="string">"error"</span></code> event:</p>

<pre><code>{ topic: <span class="keyword">function</span> () {
    <span class="keyword">var</span> promise = <span class="keyword">new</span>(events.<span class="class">EventEmitter</span>);

    fs.stat(<span class="string">'~/FILE'</span>, <span class="keyword">function</span> (e, res) {
        <span class="keyword">if</span> (e) { promise.emit(<span class="string">'error'</span>, e) }
        <span class="keyword">else</span>   { promise.emit(<span class="string">'success'</span>, res) }
    });
    <span class="keyword">return</span> promise;
  },
  <span class="string">'can be accessed'</span>: <span class="keyword">function</span> (err, stat) {
    assert.isNull   (err);        <span class="comment">// We have no error</span>
    assert.isObject (stat);       <span class="comment">// We have a stat object</span>
  },
  <span class="string">'is not empty'</span>: <span class="keyword">function</span> (err, stat) {
    assert.isNotZero (stat.size); <span class="comment">// The file size is &gt; 0</span>
  }
}
</code></pre>

<h3>Order of execution and parallelism</h3>

<p>We talked about how batches and contexts are executed briefly,
but it’s now time to delve into it in more detail:</p>

<pre><code>{ topic: <span class="keyword">function</span> () {
    fs.stat(<span class="string">'~/FILE'</span>, <span class="keyword">this</span>.callback);
  },
  <span class="string">'after a successful `fs.stat`'</span>: {
    topic: <span class="keyword">function</span> (stat) {
      fs.open(<span class="string">'~/FILE'</span>, <span class="string">"r"</span>, stat.mode, <span class="keyword">this</span>.callback);
    },
    <span class="string">'after a successful `fs.open`'</span>: {
      topic: <span class="keyword">function</span> (fd, stat) {
        fs.read(fd, stat.size, <span class="number">0</span>, <span class="string">"utf8"</span>, <span class="keyword">this</span>.callback);
      },
      <span class="string">'we can `fs.read` to get the file contents'</span>: <span class="keyword">function</span> (data) {
        assert.isString (data);
      }
    }
  }
}
</code></pre>

<p>In the example above, we make use of nested contexts to mimic nested callbacks. As you can tell,
the result of the parent topic is passed down to its children, as arguments.</p>

<p>This example as a whole is therefore mostly sequential, while remaining asynchronous.</p>

<hr>

<p>Now let’s look at an example which uses parallel tests to check for some devices:</p>

<pre><code>{ <span class="string">'/dev/stdout'</span>: {
    topic:    <span class="keyword">function</span> () { path.exists(<span class="string">'/dev/stdout'</span>, <span class="keyword">this</span>.callback) },
    <span class="string">'exists'</span>: <span class="keyword">function</span> (result) { assert.isTrue(result) }
  },
  <span class="string">'/dev/tty'</span>: {
    topic:    <span class="keyword">function</span> () { path.exists(<span class="string">'/dev/tty'</span>, <span class="keyword">this</span>.callback) },
    <span class="string">'exists'</span>: <span class="keyword">function</span> (result) { assert.isTrue(result) }
  },
  <span class="string">'/dev/null'</span>: {
    topic:    <span class="keyword">function</span> () { path.exists(<span class="string">'/dev/null'</span>, <span class="keyword">this</span>.callback) },
    <span class="string">'exists'</span>: <span class="keyword">function</span> (result) { assert.isTrue(result) }
  }
}
</code></pre>

<p>So in this case, the tests can finish in any order, and must not rely on each other. The test
suite will exit when the last I/O call completes, and the assertions for it are run.</p>

<p>In other words, <em>sibling contexts</em> are executed in parallel, while <em>nested contexts</em> are
executed sequentially. Note that this all happens asynchronously, so while some contexts
may be waiting for a parent context to finish, sibling contexts can still execute in the meantime.</p>

<h2 id="-assertions">Assertions</h2>

<p>Vows extends the assertion module which comes bundled with node, with many useful functions,
as well as better error reporting for the existing ones.</p>

<p>It’s always best to use the more specific assertion functions when testing a value,
you’ll get much better error reporting, because your intention is clearer.</p>

<p>Let’s say we have the following array:</p>

<pre><code><span class="keyword">var</span> ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
</code></pre>

<p>and try to assert that it has 5 elements. With the built-in <code>assert.equal</code>,
we would do something like this:</p>

<pre><code>assert.equal(ary.length, <span class="number">5</span>);
</code></pre>

<p>And get the following error:</p>

<pre><code>expected <span class="number">5</span>, got <span class="number">3</span>
</code></pre>

<p>Now let’s try that with one of our more specific assertion functions, <code>assert.length</code>:</p>

<pre><code>assert.length(ary, <span class="number">5</span>);
</code></pre>

<p>This reports the following error:</p>

<pre><code>expected [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] to have <span class="number">5</span> elements
</code></pre>

<p>Other useful assertion functions bundled with vows include <code>assert.match</code>, <code>assert.instanceOf</code>,
<code>assert.include</code> and <code>assert.isEmpty</code>—head over to the <a href="http://vowsjs.org/#reference">reference</a> to get the full list.</p>

<h2 id="-macros">Macros</h2>

<p>Sometimes, it’s useful to abstract tests which are used throughout the test suite. A <em>batch</em> in Vows,
is a tree-like data structure—an Object literal to be precise. This proves to be pretty powerful, as you’ll see.</p>

<p>One of the things I have to test in the  majority of the code I write are HTTP status codes. So let’s first look
at the straightforward way of doing this, given an asynchronous <code>client</code> library:</p>

<pre><code>{ topic: <span class="keyword">function</span> () {
    client.get(<span class="string">'/resources/42'</span>, <span class="keyword">this</span>.callback);
  },
  <span class="string">'should respond with a 200 OK'</span>: <span class="keyword">function</span> (e, res) {
    assert.equal (res.status, <span class="number">200</span>);
  }
}
</code></pre>

<p>Not too bad. But we might have a hundred of these, if we’re testing an API. So let’s see what we can do with macros:</p>

<pre><code><span class="keyword">function</span> assertStatus(code) {
    <span class="keyword">return</span> <span class="keyword">function</span> (e, res) {
        assert.equal (res.status, code);
    };
}
</code></pre>

<p>This is a function which takes a status code, and returns a function which tests for that status code. We can now
improve our test like this:</p>

<pre><code>{ topic: <span class="keyword">function</span> () {
    client.get(<span class="string">'/resources/42'</span>, <span class="keyword">this</span>.callback);
  },
  <span class="string">'should respond with a 200 OK'</span>: assertStatus(<span class="number">200</span>)
}
</code></pre>

<p>Much better. How about the topic? Let’s write a macro for our API calls:</p>

<pre><code><span class="keyword">var</span> api = {
    get: <span class="keyword">function</span> (path) {
        <span class="keyword">return</span> <span class="keyword">function</span> () {
            client.get(path, <span class="keyword">this</span>.callback);
        };
    }
};
</code></pre>

<p>And rewrite our tests:</p>

<pre><code>{ topic: api.get(<span class="string">'/resources/42'</span>),
  <span class="string">'should respond with a 200 OK'</span>: assertStatus(<span class="number">200</span>)
}
</code></pre>

<p>Fantastic. Here’s a an example of what these macros could look like:</p>

<pre><code>{   <span class="string">'GET /'</span>: {
        topic: api.get(<span class="string">'/'</span>),
        <span class="string">'should respond with a 200 OK'</span>: assertStatus(<span class="number">200</span>)
    },
    <span class="string">'POST /'</span>: {
        topic: api.post(<span class="string">'/'</span>),
        <span class="string">'should respond with a 405 Method not allowed'</span>: assertStatus(<span class="number">405</span>)
    },
    <span class="string">'GET /resources (no api-key)'</span>: {
        topic: api.get(<span class="string">'/resources'</span>),
        <span class="string">'should respond with a 403 Forbidden'</span>: assertStatus(<span class="number">403</span>)
    },
    <span class="string">'GET /resources?apikey=af816e859c249fe'</span>
        topic: api.get(<span class="string">'/resources?apikey=af816e859c249fe'</span>),
        <span class="string">'should return a 200 OK'</span>: assertStatus(<span class="number">200</span>),
        <span class="string">'should return a list of resources'</span>: <span class="keyword">function</span> (res) {
            assert.isArray (res.body);
        }
    }
}
</code></pre>

<p>Can we push it further? Of course we can, and this is when it gets <em>really</em> interesting. I’m going to
show you how you can generate contextual tests.</p>

<p>Instead of having a separate function which generates a <em>topic</em>, and another one which generates
a <em>vow</em>, we’re going to have a function which generates a <em>context</em> which contains both a topic and a vow.</p>

<p>The topic will perform a <em>contextual</em> request. This is the interesting part: we’re going to parse
the context description to generate the api requests. So the test will be encoded within its
description. Let’s look at a possible implementation:</p>

<pre><code><span class="comment">//</span>
<span class="comment">// Send a request and check the response status.</span>
<span class="comment">//</span>
<span class="keyword">function</span> respondsWith(status) {
    <span class="keyword">var</span> context = {
        topic: <span class="keyword">function</span> () {
            <span class="comment">// Get the current context's name, such as "POST /"</span>
            <span class="comment">// and split it at the space.</span>
            <span class="keyword">var</span> req    = <span class="keyword">this</span>.context.name.split(<span class="regexp">/ +/</span>), <span class="comment">// ["POST", "/"]</span>
                method = name[<span class="number">0</span>].toLowerCase(),         <span class="comment">// "post"</span>
                path   = name[<span class="number">1</span>];                       <span class="comment">// "/"</span>

            <span class="comment">// Perform the contextual client request,</span>
            <span class="comment">// with the above method and path.</span>
            client[method](path, <span class="keyword">this</span>.callback);
        }
    };
    <span class="comment">// Create and assign the vow to the context.</span>
    <span class="comment">// The description is generated from the expected status code</span>
    <span class="comment">// and status name, from node's http module.</span>
    context[<span class="string">'should respond with a '</span> + status + <span class="string">' '</span>
           + http.STATUS_CODES[status]] = assertStatus(status);

    <span class="keyword">return</span> context;
}
</code></pre>

<p>Now the first three contexts of our batch can be re-written as:</p>

<pre><code>{ <span class="string">'GET  /'</span>:                   respondsWith(<span class="number">200</span>),
  <span class="string">'POST /'</span>:                   respondsWith(<span class="number">405</span>),
  <span class="string">'GET  /resources (no key)'</span>: respondsWith(<span class="number">403</span>)
}
</code></pre>

<p>And when run, we get:</p>

<div class="report"><pre class="report">GET  /
  ✓ <span class="vow">should respond with a 200 OK</span>
POST /
  ✓ <span class="vow">should respond with a 405 Method Not Allowed</span>
GET  /resources (no key)
  ✓ <span class="vow">should respond with a 403 Forbidden</span>
</pre></div>


<p>The fourth context is a little more complex, as it has two vows, but I’ll let you figure that
one out!</p>

  </div>
</section>

<section id="reference">
  <div class="content">
    <h1>Reference</h1>

<p>The CLI and assertion module are documented here.</p>

<h2>Test runner</h2>

<pre><code>vows [<span class="class">FILE</span>, ...] [options]
</code></pre>

<p>Running specific tests</p>

<pre><code>$ vows test-1.js test-2.js
$ vows tests/*
</code></pre>

<p>Running all tests in your <em>test/</em> or <em>spec/</em> folder</p>

<pre><code>$ vows
</code></pre>

<p>Watch mode</p>

<pre><code>$ vows -w
$ vows --watch
</code></pre>

<hr>

<h3>Options</h3>

<table cellspacing="10">
  <tbody><tr>
    <td><code>-v</code>, <code>--verbose</code></td>
    <td>Verbose mode</td>
  </tr>
  <tr>
    <td><code>-w</code>, <code>--watch</code></td>
    <td>Watch mode</td>
  </tr>
  <tr>
    <td><code>-m <span class="class">STRING</span></code></td>
    <td>String matching: Only run tests with <code><span class="class">STRING</span></code> in their title</td>
  </tr>
  <tr>
    <td><code>-r <span class="class">REGEXP</span></code></td>
    <td>Regexp matching: Only run tests with <code><span class="class">REGEXP</span></code> in their title</td>
  </tr>
  <tr>
    <td><code>--json</code></td>
    <td>Use JSON reporter</td>
  </tr>
  <tr>
    <td><code>--spec</code></td>
    <td>Use Spec reporter</td>
  </tr>
  <tr>
    <td><code>--dot-matrix</code></td>
    <td>Use Dot-Matrix reporter</td>
  </tr>
  <!-- <tr> -->
  <!--   <td><code>-no-color</code></td> -->
  <!--   <td>Don't use terminal colors</td> -->
  <!-- </tr> -->
  <tr>
    <td><code>--version</code></td>
    <td>Show version</td>
  </tr>
  <tr>
    <td><code>-s</code>, <code>--silent</code></td>
    <td>Don't report</td>
  </tr>
  <tr>
    <td><code>--help</code></td>
    <td>Show help</td>
  </tr>
</tbody></table>


<h2>Assertion functions</h2>

<h3>equality</h3>

<pre><code>assert.equal          (<span class="number">4</span>, <span class="number">4</span>);
assert.strictEqual    (<span class="number">4</span> &gt; <span class="number">2</span>, <span class="keyword">true</span>);

assert.notEqual       (<span class="number">4</span>, <span class="number">2</span>);
assert.strictNotEqual (<span class="number">1</span>, <span class="keyword">true</span>);

assert.deepEqual      ([<span class="number">4</span>, <span class="number">2</span>], [<span class="number">4</span>, <span class="number">2</span>]);
assert.notDeepEqual   ([<span class="number">4</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">4</span>]);
</code></pre>

<h3>type</h3>

<pre><code>assert.isFunction (<span class="keyword">function</span> () {});
assert.isObject   ({goo:<span class="keyword">true</span>});
assert.isString   (<span class="string">'goo'</span>);
assert.isArray    ([<span class="number">4</span>, <span class="number">2</span>]);
assert.isNumber   (<span class="number">42</span>);
assert.isBoolean  (<span class="keyword">true</span>);

assert.typeOf     (<span class="number">42</span>, <span class="string">'number'</span>);
assert.instanceOf ([], <span class="class">Array</span>);
</code></pre>

<h3>truth</h3>

<pre><code>assert.isTrue  (<span class="keyword">true</span>);
assert.isFalse (<span class="keyword">false</span>);
</code></pre>

<h3>null, undefined, NaN</h3>

<pre><code>assert.isNull      (<span class="keyword">null</span>);
assert.isNotNull   (<span class="special">undefined</span>);

assert.isUndefined (<span class="string">'goo'</span>[<span class="number">9</span>]);
assert.isNaN       (<span class="number">0</span>/<span class="number">0</span>);
</code></pre>

<h3>inclusion</h3>

<pre><code>assert.include ([<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>], <span class="number">2</span>);
assert.include ({goo:<span class="keyword">true</span>}, <span class="string">'goo'</span>);
assert.include (<span class="string">'goo'</span>, <span class="string">'o'</span>);
</code></pre>

<h3>regexp matching</h3>

<pre><code>assert.match (<span class="string">'hello'</span>, <span class="regexp">/^[a-z]+/</span>);
</code></pre>

<h3>length</h3>

<pre><code>assert.length ([<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>], <span class="number">3</span>);
assert.length (<span class="string">'goo'</span>, <span class="number">3</span>);
</code></pre>

<h3>emptiness</h3>

<pre><code>assert.isEmpty ([]);
assert.isEmpty ({});
assert.isEmpty (<span class="string">""</span>);
</code></pre>

<h3>exceptions</h3>

<pre><code>assert.throws(<span class="keyword">function</span> () { x + x }, <span class="class">ReferenceError</span>);
assert.doesNotThrow(<span class="keyword">function</span> () { <span class="number">1</span> + <span class="number">1</span> }, <span class="class">Error</span>);
</code></pre>

  </div>
</section>

<section id="about">
  <div class="content">
    <h1>About</h1>

<p>Vows was developed by <a href="http://cloudhead.io/">Alexis Sellier</a>, more commonly known as <a href="http://cloudhead.io/">cloudhead</a>.</p>

    <footer>
        <p>powered by <a href="http://cloudhead.io/toto">toto</a>, <a href="http://github.com/cloudhead/less.js">LESS</a> and <a href="http://github.com/cloudhead/hijs">hijs</a></p>
        <p id="copy">Copyright © Alexis Sellier 2010</p>
    </footer>
  </div>
</section>

    </section>
    <a href="http://github.com/cloudhead/vows">
      <img style="position: absolute; z-index: 5; top: 0; left: 0; border: 0;" src="./Vows « Asynchronous BDD for Node_files/forkme_left_orange_ff7600.png" alt="Fork me on GitHub">
    </a>
    <script src="./Vows « Asynchronous BDD for Node_files/hijs.js"></script>
  


</body></html>